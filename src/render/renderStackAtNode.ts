import { pieceToHref } from "../pieces/pieceToHref";
import { makeUseWithTitle } from "./svgUse";
import { drawMiniStackSpine } from "./miniSpine";
import { maybeVariantStonePieceHref } from "./stonePieceVariant";
import { maybeVariantWoodenPieceHref } from "./woodenPieceVariant";
import type { Stack } from "../types";
import { pieceTooltip } from "../pieces/pieceLabel";
import { isBoardFlipped } from "./boardFlip";

type Inspector = {
  cancelHide: () => void;
  show: (nodeId: string, stack: Stack, opts?: { rulesetId?: string; boardSize?: number }) => void;
  hideSoon: () => void;
};

export function renderStackAtNode(
  svgRoot: SVGSVGElement,
  piecesLayer: SVGGElement,
  inspector: Inspector | null,
  nodeId: string,
  stack: Stack,
  opts: {
    pieceSize?: number;
    rulesetId?: string;
    boardSize?: number;
    countsLayer?: SVGGElement | null;
    spinesLayer?: SVGGElement | null;
  } = {}
): void {
  const { pieceSize = 86, rulesetId, boardSize, countsLayer, spinesLayer } = opts;

  const node = document.getElementById(nodeId) as SVGCircleElement | null;
  if (!node || !stack.length) return;

  const cx = parseFloat(node.getAttribute("cx") || "0");
  const cy = parseFloat(node.getAttribute("cy") || "0");

  const g = document.createElementNS("http://www.w3.org/2000/svg", "g") as SVGGElement;
  g.setAttribute("data-node", nodeId);
  g.setAttribute("class", "stack");

  const top = stack[stack.length - 1];
  const half = pieceSize / 2;

  const baseHref = pieceToHref(top, { rulesetId });
  const href = maybeVariantStonePieceHref(svgRoot, maybeVariantWoodenPieceHref(svgRoot, baseHref, nodeId), nodeId);
  const use = makeUseWithTitle(href, cx - half, cy - half, pieceSize, pieceTooltip(top, { rulesetId }));
  if (isBoardFlipped(svgRoot)) {
    use.setAttribute("transform", `rotate(180 ${cx} ${cy})`);
  }
  g.appendChild(use);

  const bindInspectorHover = (el: SVGGElement): void => {
    if (!inspector || stack.length <= 1) return;
    el.style.cursor = "pointer";
    el.addEventListener("pointerover", (ev) => {
      const rt = (ev as PointerEvent).relatedTarget as Node | null;
      if (rt && el.contains(rt)) return;
      inspector.cancelHide();
      inspector.show(nodeId, stack, { rulesetId, boardSize });
    });
    el.addEventListener("pointerout", (ev) => {
      const rt = (ev as PointerEvent).relatedTarget as Node | null;
      if (rt && el.contains(rt)) return;
      inspector.hideSoon();
    });
  };

  const spineTarget = spinesLayer ?? g;
  const spineG =
    spineTarget === g
      ? g
      : (document.createElementNS("http://www.w3.org/2000/svg", "g") as SVGGElement);

  if (spineG !== g) {
    spineG.setAttribute("data-node", nodeId);
    spineG.setAttribute("class", "miniSpine");
    spineTarget.appendChild(spineG);
  }

  drawMiniStackSpine(svgRoot, spineG, cx, cy, stack, {
    pieceSize,
    miniSize: 18,
    rulesetId,
    seedKey: nodeId,
    countLayer: countsLayer ?? undefined,
  });

  bindInspectorHover(g);
  if (spineG !== g) bindInspectorHover(spineG);

  piecesLayer.appendChild(g);
}

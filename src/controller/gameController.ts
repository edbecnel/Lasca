import type { GameState } from "../game/state.ts";
import type { Move } from "../game/moveTypes.ts";
import type { createStackInspector } from "../ui/stackInspector";
import { ensureOverlayLayer, clearOverlays, drawSelection, drawTargets, drawHighlightRing } from "../render/overlays.ts";
import { generateLegalMoves } from "../game/movegen.ts";
import { renderGameState } from "../render/renderGameState.ts";
import { RULES } from "../game/ruleset.ts";
import { getWinner, checkCurrentPlayerLost } from "../game/gameOver.ts";
import { HistoryManager } from "../game/historyManager.ts";
import { hashGameState } from "../game/hashState.ts";
import {
  adjudicateDamascaDeadPlay,
  DAMASCA_NO_PROGRESS_LIMIT_PLIES,
  DAMASCA_OFFICER_ONLY_LIMIT_PLIES,
} from "../game/damascaDeadPlay.ts";
import { animateStack } from "../render/animateMove.ts";
import { ensureStackCountsLayer } from "../render/stackCountsLayer.ts";
import { nodeIdToA1 } from "../game/coordFormat.ts";
import { getDamaCaptureRemovalMode } from "../game/damaCaptureChain.ts";
import { parseNodeId } from "../game/coords.ts";
import { endTurn } from "../game/endTurn.ts";
import { ensurePreviewLayer, clearPreviewLayer } from "../render/previewLayer.ts";
import { ensureTurnIndicatorLayer, renderTurnIndicator } from "../render/turnIndicator.ts";
import {
  ensureOpponentPresenceIndicatorLayer,
  renderOpponentPresenceIndicator,
} from "../render/opponentPresenceIndicator.ts";
import type { GameDriver } from "../driver/gameDriver.ts";
import type { OnlineGameDriver } from "../driver/gameDriver.ts";
import { LocalDriver } from "../driver/localDriver.ts";
import { deserializeWireGameState } from "../shared/wireState.ts";
import type { GetRoomWatchTokenResponse, PostRoomDebugReportResponse } from "../shared/onlineProtocol.ts";
import type { SfxManager, SfxName } from "../ui/sfx.ts";

export type HistoryChangeReason = "move" | "undo" | "redo" | "jump" | "newGame" | "loadGame" | "gameOver";

export class GameController {
  private svg: SVGSVGElement;
  private piecesLayer: SVGGElement;
  private inspector: ReturnType<typeof createStackInspector> | null;
  private overlayLayer: SVGGElement;
  private previewLayer: SVGGElement;
  private turnIndicatorLayer: SVGGElement;
  private opponentPresenceIndicatorLayer: SVGGElement;
  private lastOpponentDisconnectedBlockToastAt: number = 0;

  private didBindOpponentStatusClicks: boolean = false;
  private state: GameState;
  private selected: string | null = null;
  private currentTargets: string[] = [];
  private currentMoves: Move[] = [];
  private mandatoryCapture: boolean = false;
  private lockedCaptureFrom: string | null = null;
  private lockedCaptureDir: { dr: number; dc: number } | null = null;
  private jumpedSquares: Set<string> = new Set();
  private isGameOver: boolean = false;
  private moveHintsEnabled: boolean = false;
  private animationsEnabled: boolean = true;
  private bannerTimer: number | null = null;
  private remainderTimer: number | null = null;
  private history: HistoryManager;
  private driver: GameDriver;
  private historyListeners: Array<(reason: HistoryChangeReason) => void> = [];
  private inputEnabled: boolean = true;
  private lastInputEnabled: boolean = true;
  private currentTurnNodes: string[] = []; // Track node IDs visited in current turn
  private currentTurnHasCapture: boolean = false; // Track if current turn includes captures
  private repetitionCounts: Map<string, number> = new Map();
  private onlinePollTimer: number | null = null;
  private onlineRealtimeEnabled: boolean = false;
  private onlineTransportStatus: "connected" | "reconnecting" = "connected";
  private onlineDidShowConnectingToast: boolean = false;
  private onlineDidShowConnectedToast: boolean = false;
  private reportIssueHintShownForRoomId: string | null = null;
  private reportIssueHintLastShownAtMs: number = 0;
  private lastDeadPlayWarning: string | null = null;
  private lastGameOverToast: string | null = null;
  private lastToastToMove: GameState["toMove"] | null = null;
  private toastTimer: number | null = null;
  private toastEl: HTMLDivElement | null = null;
  private stickyToastKey: string | null = null;
  private stickyToastText: string | null = null;
  private stickyToastActions: Map<string, () => void> = new Map();

  private readonly cursorMarkedSelectableStacks: Set<string> = new Set();
  private readonly cursorMarkedTargets: Set<string> = new Set();

  private sfx: SfxManager | null = null;

  private lastOpponentPresent: boolean | null = null;
  private lastOpponentConnected: boolean | null = null;
  private everSawOpponentPresent: boolean = false;

  private static readonly TOAST_PREF_KEY = "lasca.opt.toasts";

  private replayEl: HTMLDivElement | null = null;
  private replaySnapshots: Array<{ stateVersion: number; ts: string; state: GameState; summary: string }> = [];
  private replayIndex: number = 0;
  private replaySavedState: { state: GameState; isGameOver: boolean } | null = null;

  private debugEl: HTMLDivElement | null = null;

  setSfxManager(sfx: SfxManager | null): void {
    this.sfx = sfx;
  }

  private playSfx(name: SfxName): void {
    try {
      this.sfx?.play(name);
    } catch {
      // ignore
    }
  }

  private inferMoveSfx(prev: GameState, next: GameState): SfxName {
    // Heuristic: capture => piece count drops; promotion => officer count rises.
    let prevTotal = 0;
    let nextTotal = 0;
    let prevOfficers = 0;
    let nextOfficers = 0;

    for (const [, stack] of prev.board.entries()) {
      prevTotal += stack.length;
      for (const p of stack) if (p.rank === "O") prevOfficers += 1;
    }
    for (const [, stack] of next.board.entries()) {
      nextTotal += stack.length;
      for (const p of stack) if (p.rank === "O") nextOfficers += 1;
    }

    if (nextTotal < prevTotal) return "capture";
    if (nextOfficers > prevOfficers) return "promote";
    return "move";
  }

  private async copyTextToClipboard(text: string): Promise<boolean> {
    if (!text) return false;

    // Modern async clipboard API (works on https and usually localhost).
    try {
      const anyNav = typeof navigator !== "undefined" ? (navigator as any) : null;
      const clip = anyNav?.clipboard;
      if (clip && typeof clip.writeText === "function") {
        await clip.writeText(text);
        return true;
      }
    } catch {
      // fall through to legacy fallback
    }

    // Legacy fallback.
    if (typeof document === "undefined") return false;
    try {
      const ta = document.createElement("textarea");
      ta.value = text;
      ta.setAttribute("readonly", "");
      ta.style.position = "fixed";
      ta.style.left = "-9999px";
      ta.style.top = "-9999px";
      document.body.appendChild(ta);
      ta.select();
      ta.setSelectionRange(0, ta.value.length);
      const ok = document.execCommand("copy");
      ta.remove();
      return ok;
    } catch {
      return false;
    }
  }

  private buildOnlineInviteLink(): string | null {
    if (this.driver.mode !== "online") return null;
    const remote = this.driver as OnlineGameDriver;
    const serverUrl = remote.getServerUrl();
    const roomId = remote.getRoomId();
    if (!serverUrl || !roomId) return null;

    try {
      const url = new URL(window.location.href);
      url.searchParams.set("mode", "online");
      url.searchParams.set("server", serverUrl);
      url.searchParams.set("roomId", roomId);
      url.searchParams.set("join", "1");
      url.searchParams.delete("create");
      url.searchParams.delete("playerId");
      url.searchParams.delete("color");
      url.searchParams.delete("prefColor");
      url.searchParams.delete("visibility");
      url.searchParams.delete("watchToken");
      return url.toString();
    } catch {
      return null;
    }
  }

  private copyOnlineInviteLink(): void {
    const link = this.buildOnlineInviteLink();
    if (!link) return;
    void (async () => {
      const ok = await this.copyTextToClipboard(link);
      this.showToast(ok ? "Invite link copied" : "Clipboard copy failed", 1800);
    })();
  }

  private bindRoomIdCopyButton(): void {
    const btn = document.getElementById("copyRoomIdBtn") as HTMLButtonElement | null;
    if (!btn) return;

    btn.addEventListener("click", async () => {
      if (this.driver.mode !== "online") return;
      const roomId = (this.driver as OnlineGameDriver).getRoomId();
      if (!roomId) return;
      await this.copyTextToClipboard(roomId);
    });
  }

  private bindWatchLinkCopyButton(): void {
    const btn = document.getElementById("copyWatchLinkBtn") as HTMLButtonElement | null;
    if (!btn) return;

    btn.addEventListener("click", async () => {
      if (this.driver.mode !== "online") return;
      const remote = this.driver as OnlineGameDriver;

      const serverUrl = remote.getServerUrl();
      const roomId = remote.getRoomId();
      const playerId = remote.getPlayerId();
      if (!serverUrl || !roomId || !playerId || playerId === "spectator") return;

      try {
        const url = new URL(`/api/room/${encodeURIComponent(roomId)}/watchToken`, serverUrl);
        url.searchParams.set("playerId", playerId);
        const res = await fetch(url.toString());
        const data = (await res.json()) as GetRoomWatchTokenResponse;
        if (!res.ok || (data as any)?.error) {
          const msg = typeof (data as any)?.error === "string" ? (data as any).error : `HTTP ${res.status}`;
          this.showToast(`Failed to get watch link (${msg})`, 2200);
          return;
        }

        const tok = typeof (data as any)?.watchToken === "string" ? String((data as any).watchToken) : "";
        const vis = (data as any)?.visibility;
        if (vis !== "private" || !tok) {
          this.showToast("No watch link (room is public)", 1800);
          return;
        }

        // Share a direct link to the current variant page.
        const share = new URL(window.location.href);
        share.searchParams.set("mode", "online");
        share.searchParams.set("server", serverUrl);
        share.searchParams.set("roomId", roomId);
        share.searchParams.set("watchToken", tok);
        // Ensure the receiver opens as spectator.
        share.searchParams.delete("playerId");
        share.searchParams.delete("color");
        share.searchParams.delete("create");
        share.searchParams.delete("join");
        share.searchParams.delete("prefColor");
        share.searchParams.delete("visibility");

        const copiedOk = await this.copyTextToClipboard(share.toString());
        this.showToast(copiedOk ? "Copied spectate link" : "Failed to copy spectate link", 1800);
      } catch {
        this.showToast("Failed to get watch link", 1800);
      }
    });
  }

  private bindDebugCopyButton(): void {
    const btn = document.getElementById("copyDebugBtn") as HTMLButtonElement | null;
    if (!btn) return;

    btn.addEventListener("click", async () => {
      if (this.driver.mode !== "online") return;
      const remote = this.driver as OnlineGameDriver;

      const serverUrl = remote.getServerUrl();
      const roomId = remote.getRoomId();
      const playerId = remote.getPlayerId();

      const debug = {
        app: { name: "lasca", version: "0.1.0" },
        whenIso: new Date().toISOString(),
        online: {
          serverUrl,
          roomId,
          playerId,
          playerColor: remote.getPlayerColor(),
          transport: this.onlineTransportStatus,
          presence: remote.getPresence(),
        },
        game: {
          variantId: (this.state as any)?.meta?.variantId ?? null,
          rulesetId: (this.state as any)?.meta?.rulesetId ?? null,
          stateVersion: (this.state as any)?.stateVersion ?? null,
          toMove: this.state.toMove,
          phase: this.state.phase,
          isGameOver: this.isGameOver,
          forcedGameOver: (this.state as any)?.forcedGameOver ?? null,
        },
        ua: typeof navigator !== "undefined" ? (navigator as any).userAgent : null,
      };

      const text = JSON.stringify(debug, null, 2);

      // Always show the text box so users can manually copy/paste if clipboard fails.
      this.openDebugModal({ text, status: "Preparing debug info…" });

      const copiedOk = await this.copyTextToClipboard(text);

      // Keep the toast behavior stable: show copy outcome immediately.
      this.showToast(copiedOk ? "Copied debug info" : "Failed to copy debug info", 1600);

      // Fire-and-forget upload to server for per-room logging.
      void (async () => {
        let savedOk = false;
        let savedFileName: string | null = null;
        try {
          if (serverUrl && roomId) {
            const url = new URL(`/api/room/${encodeURIComponent(roomId)}/debug`, serverUrl);
            const res = await fetch(url.toString(), {
              method: "POST",
              headers: { "content-type": "application/json" },
              body: JSON.stringify({ roomId, playerId, debug }),
            });

            const data = (await res.json()) as PostRoomDebugReportResponse;
            if (res.ok && (data as any)?.ok) {
              savedOk = true;
              savedFileName = (data as any).fileName ?? null;
            }
          }
        } catch {
          // ignore
        }

        const statusParts: string[] = [];
        statusParts.push(copiedOk ? "Copied to clipboard" : "Clipboard copy failed");
        statusParts.push(savedOk ? (savedFileName ? `Saved on server (${savedFileName})` : "Saved on server") : "Server save failed");
        this.openDebugModal({ text, status: statusParts.join(" · ") });
      })();
    });
  }

  private ensureDebugEl(): HTMLDivElement | null {
    if (typeof document === "undefined") return null;
    if (this.debugEl && document.body.contains(this.debugEl)) return this.debugEl;

    const styleId = "lasca-debug-style";
    if (!document.getElementById(styleId)) {
      const style = document.createElement("style");
      style.id = styleId;
      style.textContent = `
        .lascaDebugBackdrop {
          position: fixed;
          inset: 0;
          background: rgba(0,0,0,0.55);
          z-index: 99999;
          display: none;
        }
        .lascaDebugBackdrop.isOpen { display: block; }
        .lascaDebugCard {
          position: absolute;
          left: 50%;
          top: 50%;
          transform: translate(-50%, -50%);
          width: min(92vw, 820px);
          max-height: min(86vh, 760px);
          overflow: hidden;
          border-radius: 14px;
          background: rgba(0, 0, 0, 0.90);
          border: 1px solid rgba(255,255,255,0.16);
          color: rgba(255,255,255,0.92);
          box-shadow: 0 20px 60px rgba(0,0,0,0.6);
          padding: 14px;
          font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
          display: flex;
          flex-direction: column;
          gap: 10px;
        }
        .lascaDebugTop {
          display: flex;
          align-items: center;
          justify-content: space-between;
          gap: 10px;
        }
        .lascaDebugTitle { font-size: 14px; font-weight: 800; letter-spacing: 0.2px; }
        .lascaDebugStatus { font-size: 12px; opacity: 0.85; }
        .lascaDebugText {
          width: 100%;
          flex: 1;
          min-height: 220px;
          resize: none;
          background: rgba(255,255,255,0.06);
          color: rgba(255,255,255,0.92);
          border: 1px solid rgba(255,255,255,0.18);
          border-radius: 10px;
          padding: 10px;
          font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
          font-size: 12px;
          line-height: 1.35;
          outline: none;
          overflow: auto;
        }
        .lascaDebugActions {
          display: flex;
          justify-content: flex-end;
          gap: 8px;
        }
        .lascaDebugBtn {
          appearance: none;
          border: 1px solid rgba(255,255,255,0.18);
          background: rgba(255,255,255,0.06);
          color: rgba(255,255,255,0.92);
          border-radius: 10px;
          padding: 8px 10px;
          font-size: 12px;
          cursor: pointer;
        }
        .lascaDebugBtn:hover { background: rgba(255,255,255,0.1); }
      `;
      document.head.appendChild(style);
    }

    const backdrop = document.createElement("div");
    backdrop.className = "lascaDebugBackdrop";
    backdrop.setAttribute("role", "dialog");
    backdrop.setAttribute("aria-modal", "true");

    const card = document.createElement("div");
    card.className = "lascaDebugCard";

    const top = document.createElement("div");
    top.className = "lascaDebugTop";

    const left = document.createElement("div");
    const title = document.createElement("div");
    title.className = "lascaDebugTitle";
    title.textContent = "Debug info";
    const status = document.createElement("div");
    status.className = "lascaDebugStatus";
    status.id = "lascaDebugStatus";
    status.textContent = "";
    left.appendChild(title);
    left.appendChild(status);

    const closeBtn = document.createElement("button");
    closeBtn.className = "lascaDebugBtn";
    closeBtn.textContent = "Close";
    closeBtn.addEventListener("click", () => this.closeDebugModal());

    top.appendChild(left);
    top.appendChild(closeBtn);

    const textarea = document.createElement("textarea");
    textarea.className = "lascaDebugText";
    textarea.id = "lascaDebugText";
    textarea.setAttribute("spellcheck", "false");
    textarea.setAttribute("wrap", "off");

    const actions = document.createElement("div");
    actions.className = "lascaDebugActions";

    const copyBtn = document.createElement("button");
    copyBtn.className = "lascaDebugBtn";
    copyBtn.textContent = "Copy";
    copyBtn.addEventListener("click", async () => {
      const text = textarea.value || "";
      const ok = await this.copyTextToClipboard(text);
      this.showToast(ok ? "Copied debug info" : "Failed to copy debug info", 1600);
      if (!ok) {
        try {
          textarea.focus();
          textarea.select();
        } catch {
          // ignore
        }
      }
    });

    actions.appendChild(copyBtn);

    card.appendChild(top);
    card.appendChild(textarea);
    card.appendChild(actions);
    backdrop.appendChild(card);

    backdrop.addEventListener("click", (ev) => {
      if (ev.target === backdrop) this.closeDebugModal();
    });

    window.addEventListener("keydown", (ev) => {
      if (!this.debugEl) return;
      if (!this.debugEl.classList.contains("isOpen")) return;
      if (ev.key === "Escape") this.closeDebugModal();
    });

    document.body.appendChild(backdrop);
    this.debugEl = backdrop;
    return backdrop;
  }

  private openDebugModal(args: { text: string; status?: string }): void {
    const el = this.ensureDebugEl();
    if (!el) return;

    const ta = el.querySelector("#lascaDebugText") as HTMLTextAreaElement | null;
    const statusEl = el.querySelector("#lascaDebugStatus") as HTMLDivElement | null;
    if (ta) ta.value = args.text;
    if (statusEl) statusEl.textContent = args.status ?? "";

    el.classList.add("isOpen");
    try {
      ta?.focus();
      ta?.select();
    } catch {
      // ignore
    }
  }

  private closeDebugModal(): void {
    if (!this.debugEl) return;
    this.debugEl.classList.remove("isOpen");
  }

  private bindReplayButton(): void {
    const btn = document.getElementById("openReplayBtn") as HTMLButtonElement | null;
    if (!btn) return;

    btn.addEventListener("click", async () => {
      if (this.driver.mode !== "online") return;
      if (!this.isGameOver) {
        this.showToast("Replay is available after game over", 1600);
        return;
      }
      await this.openReplayViewer();
    });
  }

  private ensureReplayEl(): HTMLDivElement | null {
    if (typeof document === "undefined") return null;
    if (this.replayEl && document.body.contains(this.replayEl)) return this.replayEl;

    const styleId = "lasca-replay-style";
    if (!document.getElementById(styleId)) {
      const style = document.createElement("style");
      style.id = styleId;
      style.textContent = `
        .lascaReplayBackdrop {
          position: fixed;
          inset: 0;
          background: rgba(0,0,0,0.55);
          z-index: 99998;
          display: none;
        }
        .lascaReplayBackdrop.isOpen { display: block; }
        .lascaReplayCard {
          position: absolute;
          left: 50%;
          top: 50%;
          transform: translate(-50%, -50%);
          width: min(92vw, 720px);
          max-height: min(86vh, 720px);
          overflow: auto;
          border-radius: 14px;
          background: rgba(0, 0, 0, 0.86);
          border: 1px solid rgba(255,255,255,0.16);
          color: rgba(255,255,255,0.92);
          box-shadow: 0 20px 60px rgba(0,0,0,0.6);
          padding: 14px;
          font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
        }
        .lascaReplayTop {
          display: flex;
          align-items: center;
          justify-content: space-between;
          gap: 10px;
          margin-bottom: 10px;
        }
        .lascaReplayTitle { font-size: 14px; font-weight: 800; letter-spacing: 0.2px; }
        .lascaReplayBtn {
          appearance: none;
          border: 1px solid rgba(255,255,255,0.18);
          background: rgba(255,255,255,0.06);
          color: rgba(255,255,255,0.92);
          border-radius: 10px;
          padding: 8px 10px;
          font-size: 12px;
          cursor: pointer;
        }
        .lascaReplayBtn:disabled { opacity: 0.4; cursor: not-allowed; }
        .lascaReplayBtn:hover { background: rgba(255,255,255,0.1); }
        .lascaReplayRow { display:flex; align-items:center; gap:8px; margin: 10px 0; }
        .lascaReplayMeta { color: rgba(255,255,255,0.7); font-size: 12px; }
        .lascaReplayList {
          margin-top: 10px;
          border-top: 1px solid rgba(255,255,255,0.12);
          padding-top: 10px;
        }
        .lascaReplayItem {
          font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
          font-size: 12px;
          color: rgba(255,255,255,0.88);
          padding: 6px 0;
          border-bottom: 1px solid rgba(255,255,255,0.08);
        }
      `;
      document.head.appendChild(style);
    }

    const backdrop = document.createElement("div");
    backdrop.className = "lascaReplayBackdrop";

    const card = document.createElement("div");
    card.className = "lascaReplayCard";
    card.innerHTML = `
      <div class="lascaReplayTop">
        <div class="lascaReplayTitle">Replay</div>
        <button class="lascaReplayBtn" type="button" data-action="close">Close</button>
      </div>
      <div class="lascaReplayMeta" data-el="summary">Loading…</div>
      <div class="lascaReplayRow">
        <button class="lascaReplayBtn" type="button" data-action="prev">Prev</button>
        <button class="lascaReplayBtn" type="button" data-action="next">Next</button>
        <span class="lascaReplayMeta" data-el="pos">—</span>
      </div>
      <div class="lascaReplayList" data-el="list"></div>
    `;

    backdrop.appendChild(card);
    document.body.appendChild(backdrop);

    backdrop.addEventListener("click", (ev) => {
      if (ev.target === backdrop) this.closeReplayViewer();
    });

    card.addEventListener("click", (ev) => {
      const el = ev.target as HTMLElement | null;
      const act = el?.getAttribute("data-action");
      if (act === "close") this.closeReplayViewer();
      if (act === "prev") this.replayStep(-1);
      if (act === "next") this.replayStep(1);
    });

    this.replayEl = backdrop;
    return backdrop;
  }

  private renderReplayUi(): void {
    const el = this.replayEl;
    if (!el) return;

    const summaryEl = el.querySelector('[data-el="summary"]') as HTMLElement | null;
    const posEl = el.querySelector('[data-el="pos"]') as HTMLElement | null;
    const listEl = el.querySelector('[data-el="list"]') as HTMLElement | null;
    const prevBtn = el.querySelector('[data-action="prev"]') as HTMLButtonElement | null;
    const nextBtn = el.querySelector('[data-action="next"]') as HTMLButtonElement | null;

    if (prevBtn) prevBtn.disabled = this.replayIndex <= 0;
    if (nextBtn) nextBtn.disabled = this.replayIndex >= this.replaySnapshots.length - 1;

    if (posEl) {
      posEl.textContent = this.replaySnapshots.length
        ? `${this.replayIndex + 1} / ${this.replaySnapshots.length}`
        : "—";
    }

    if (summaryEl) {
      if (this.replaySnapshots.length === 0) summaryEl.textContent = "No replay snapshots found.";
      else {
        const cur = this.replaySnapshots[this.replayIndex];
        summaryEl.textContent = `Showing v${cur.stateVersion} • ${cur.ts}`;
      }
    }

    if (listEl) {
      listEl.innerHTML = "";
      for (let i = 0; i < this.replaySnapshots.length; i++) {
        const s = this.replaySnapshots[i];
        const div = document.createElement("div");
        div.className = "lascaReplayItem";
        div.textContent = `${i === this.replayIndex ? ">" : " "} v${s.stateVersion} ${s.summary}`;
        listEl.appendChild(div);
      }
    }
  }

  private replayStep(delta: number): void {
    if (this.replaySnapshots.length === 0) return;
    const next = Math.max(0, Math.min(this.replaySnapshots.length - 1, this.replayIndex + delta));
    if (next === this.replayIndex) return;
    this.replayIndex = next;
    const snap = this.replaySnapshots[this.replayIndex];
    this.state = snap.state;
    this.renderAuthoritative();
    this.renderReplayUi();
  }

  private async openReplayViewer(): Promise<void> {
    if (this.driver.mode !== "online") return;
    const remote = this.driver as OnlineGameDriver;
    const el = this.ensureReplayEl();
    if (!el) return;

    this.replaySavedState = { state: this.state, isGameOver: this.isGameOver };
    this.setInputEnabled(false);

    el.classList.add("isOpen");

    let events: any[] = [];
    try {
      events = await remote.fetchReplayEvents({ limit: 5000 });
    } catch (err) {
      const msg = err instanceof Error ? err.message : "Replay fetch failed";
      this.showToast(msg, 2000);
      this.closeReplayViewer();
      return;
    }

    const snaps: Array<{ stateVersion: number; ts: string; state: GameState; summary: string }> = [];
    for (const ev of events) {
      const w = (ev as any)?.snapshot;
      if (!w) continue;
      const st = deserializeWireGameState(w.state) as any;
      const stateVersion = Number(w.stateVersion ?? (ev as any)?.stateVersion ?? -1);
      const ts = typeof (ev as any)?.ts === "string" ? (ev as any).ts : "";
      const t = String((ev as any)?.type ?? "EVENT");
      const action = (ev as any)?.action ? ` ${String((ev as any).action)}` : "";
      const summary = `${t}${action}`;
      snaps.push({ stateVersion, ts, state: st as GameState, summary });
    }

    // Sort by stateVersion for deterministic stepping.
    snaps.sort((a, b) => a.stateVersion - b.stateVersion);

    this.replaySnapshots = snaps;
    this.replayIndex = Math.max(0, this.replaySnapshots.length - 1);

    if (this.replaySnapshots.length > 0) {
      const cur = this.replaySnapshots[this.replayIndex];
      this.state = cur.state;
      this.renderAuthoritative();
    }

    this.renderReplayUi();
  }

  private closeReplayViewer(): void {
    const el = this.replayEl;
    if (el) el.classList.remove("isOpen");

    const saved = this.replaySavedState;
    this.replaySavedState = null;
    this.replaySnapshots = [];
    this.replayIndex = 0;

    this.setInputEnabled(true);

    if (saved) {
      this.state = saved.state;
      this.isGameOver = saved.isGameOver;
      this.renderAuthoritative();
      this.updatePanel();
    }
  }

  private onlineHasOpponent(): boolean {
    if (this.driver.mode !== "online") return true;
    const remote = this.driver as OnlineGameDriver;
    const selfId = remote.getPlayerId();
    if (!selfId || selfId === "spectator") return false;
    const presence = remote.getPresence();
    if (!presence) return false;
    const opponentId = Object.keys(presence).find((pid) => pid !== selfId) ?? null;
    return Boolean(opponentId);
  }

  private maybeShowOnlineWaitingInviteToast(): void {
    // Only show a "room created" waiting toast before we've ever seen an opponent.
    if (this.driver.mode !== "online") {
      this.clearStickyToast("online_waiting_invite");
      return;
    }
    if (this.isGameOver) {
      this.clearStickyToast("online_waiting_invite");
      return;
    }

    const remote = this.driver as OnlineGameDriver;
    const selfId = remote.getPlayerId();
    if (!selfId || selfId === "spectator") {
      this.clearStickyToast("online_waiting_invite");
      return;
    }

    const shouldShow = !this.onlineHasOpponent() && this.everSawOpponentPresent === false;
    if (!shouldShow) {
      this.clearStickyToast("online_waiting_invite");
      return;
    }

    const key = "online_waiting_invite";

    // Don't clobber non-online sticky toasts (e.g. report issue).
    if (this.stickyToastKey && this.stickyToastKey !== key && !this.stickyToastKey.startsWith("online_")) {
      return;
    }

    this.setStickyToastAction(key, () => this.copyOnlineInviteLink());
    // Force: this is onboarding UX and should appear even if the user previously
    // disabled toasts in a different mode.
    this.showStickyToast(key, "Waiting for opponent… Tap to copy invite link", { force: true });
  }

  private isLocalPlayersTurn(): boolean {
    if (this.driver.mode !== "online") return true;
    const color = (this.driver as OnlineGameDriver).getPlayerColor();
    if (!color) return false;
    // Per multiplayer checklist: no play allowed until both seats are filled.
    if (!this.onlineHasOpponent()) return false;
    return this.state.toMove === color;
  }

  private startOnlinePolling(): void {
    if (this.driver.mode !== "online") return;
    const remote = this.driver as OnlineGameDriver;
    if (this.onlinePollTimer || this.onlineRealtimeEnabled) return;
    
    // Presence can change without a stateVersion bump.
    // Refresh panel so opponent shows Connected immediately (no click required).
    remote.onSseEvent("snapshot", (payload) => {
      if (payload?.presence) this.updatePanel();
    });

    // Surface initial connection state.
    if (!this.onlineDidShowConnectingToast && !this.isGameOver) {
      this.onlineDidShowConnectingToast = true;
      this.showToast("Connecting…", 1400);
    }

    // Prefer realtime server push (WebSockets; falls back to SSE). Falls back to polling if unavailable.
    // Transport status events are emitted by the driver (WS primary).
    remote.onSseEvent("transport_status", (payload) => {
      if (this.isGameOver) return;
      const status = payload?.status === "reconnecting" ? "reconnecting" : "connected";
      if (this.onlineTransportStatus === status) return;
      const prevStatus = this.onlineTransportStatus;
      this.onlineTransportStatus = status;
      this.updatePanel();

      if (status === "reconnecting") {
        const key = "online_reconnecting";

        // Don't clobber non-online sticky toasts (e.g. report issue).
        if (!this.stickyToastKey || this.stickyToastKey === key || this.stickyToastKey.startsWith("online_")) {
          // Click-to-dismiss is handled by the default sticky toast behavior.
          this.setStickyToastAction(key, null);
          this.showStickyToast(key, "Connection to server was lost — attempting to reconnect. Tap to dismiss.", {
            force: true,
          });
        }
        this.maybeShowReportIssueHintToast("Connection problem");
      } else if (prevStatus === "reconnecting" && status === "connected") {
        this.clearStickyToast("online_reconnecting");
        this.showToast("Reconnected", 1400);

        // Restore any contextual online sticky toast (e.g. waiting invite) if applicable.
        this.maybeShowOnlineWaitingInviteToast();
      }

      // On reconnect, re-toast the current turn state.
      if (prevStatus === "reconnecting" && status === "connected") {
        this.lastToastToMove = null;
      }
      this.maybeToastTurnChange();
    });

    const startedRealtime = remote.startRealtime(() => {
      if (this.isGameOver) return;

      if (!this.onlineDidShowConnectedToast) {
        this.onlineDidShowConnectedToast = true;
        this.showToast("Connected", 1100);
      }

      this.state = remote.getState();
      // Any opponent update invalidates local in-progress UI selection/chain.
      this.lockedCaptureFrom = null;
      this.lockedCaptureDir = null;
      this.jumpedSquares.clear();
      this.currentTurnNodes = [];
      this.currentTurnHasCapture = false;
      this.clearSelection();
      this.renderAuthoritative();

      const allLegal = generateLegalMoves(this.state);
      this.mandatoryCapture = allLegal.length > 0 && allLegal[0].kind === "capture";
      this.recomputeRepetitionCounts();
      this.checkAndHandleCurrentPlayerLost();
      this.updatePanel();

      // Opponent updates can make it our turn.
      this.maybeToastTurnChange();

      this.fireHistoryChange("move");
    });

    if (startedRealtime) {
      this.onlineRealtimeEnabled = true;
      return;
    }

    // Simple polling keeps both tabs in sync without websockets.
    this.onlinePollTimer = window.setInterval(async () => {
      if (this.isGameOver) return;
      try {
        const updated = await remote.fetchLatest();
        if (!updated) return;

        this.state = remote.getState();
        // Any opponent update invalidates local in-progress UI selection/chain.
        this.lockedCaptureFrom = null;
        this.lockedCaptureDir = null;
        this.jumpedSquares.clear();
        this.currentTurnNodes = [];
        this.currentTurnHasCapture = false;
        this.clearSelection();
        this.renderAuthoritative();

        const allLegal = generateLegalMoves(this.state);
        this.mandatoryCapture = allLegal.length > 0 && allLegal[0].kind === "capture";
        this.recomputeRepetitionCounts();
        this.checkAndHandleCurrentPlayerLost();
        this.updatePanel();

        // Poll updates can make it our turn.
        this.maybeToastTurnChange();

        // Remote snapshots can advance history/notation; notify listeners so UI updates
        // (e.g., move list) without requiring local input.
        this.fireHistoryChange("move");
      } catch {
        // Ignore transient network errors; server is best-effort.
      }
    }, 750);
  }

  private isBothSidesAIFromPrefs(): boolean {
    // Observer mode heuristic: if both AI difficulty prefs are set to non-human.
    // Keep this local (no imports) to avoid cycles; just treat anything but "human" as AI.
    if (this.driver.mode === "online") return false;
    if (typeof localStorage === "undefined") return false;
    const w = localStorage.getItem("lasca.ai.white");
    const b = localStorage.getItem("lasca.ai.black");
    return Boolean(w && w !== "human" && b && b !== "human");
  }

  private readToastPref(): boolean {
    if (typeof localStorage === "undefined") return true;
    const raw = localStorage.getItem(GameController.TOAST_PREF_KEY);
    if (raw == null) return !this.isBothSidesAIFromPrefs(); // default ON, except AI-vs-AI observer mode
    if (raw === "1" || raw === "true") return true;
    if (raw === "0" || raw === "false") return false;
    return true;
  }

  private ensureToastEl(): HTMLDivElement | null {
    if (typeof document === "undefined") return null;
    if (this.toastEl && document.body.contains(this.toastEl)) return this.toastEl;

    // Inject styles once.
    const styleId = "lasca-toast-style";
    if (!document.getElementById(styleId)) {
      const style = document.createElement("style");
      style.id = styleId;
      style.textContent = `
        .lascaToastWrap {
          position: fixed;
          left: 50%;
          top: 50%;
          transform: translate(-50%, -50%);
          z-index: 99999;
          pointer-events: auto;
          display: none;
        }
        .lascaToast {
          max-width: min(92vw, 560px);
          padding: 12px 16px;
          border-radius: 14px;
          background: rgba(0, 0, 0, 0.78);
          border: 1px solid rgba(255, 255, 255, 0.18);
          color: rgba(255, 255, 255, 0.96);
          font-size: 16px;
          font-weight: 750;
          letter-spacing: 0.2px;
          text-align: center;
          box-shadow: 0 10px 30px rgba(0, 0, 0, 0.55);
          opacity: 0;
          transform: scale(0.98);
          transition: opacity 140ms ease, transform 140ms ease;
          cursor: pointer;
        }
        .lascaToastWrap.isVisible { display: block; }
        .lascaToastWrap.isVisible .lascaToast {
          opacity: 1;
          transform: scale(1);
        }
      `;
      document.head.appendChild(style);
    }

    const wrap = document.createElement("div");
    wrap.className = "lascaToastWrap";
    wrap.setAttribute("aria-live", "polite");
    wrap.setAttribute("role", "status");

    const inner = document.createElement("div");
    inner.className = "lascaToast";
    inner.textContent = "";
    inner.setAttribute("role", "button");
    inner.tabIndex = 0;
    const dismiss = (e: Event) => {
      e.preventDefault();
      e.stopPropagation();

      // If a timed toast is currently showing (possibly temporarily replacing
      // a sticky toast), clicking should dismiss the timed toast first.
      if (this.toastTimer) {
        window.clearTimeout(this.toastTimer);
        this.toastTimer = null;

        if (this.stickyToastKey && this.stickyToastText) {
          inner.textContent = this.stickyToastText;
          this.toastEl?.classList.add("isVisible");
        } else {
          this.toastEl?.classList.remove("isVisible");
        }
        return;
      }

      if (this.stickyToastKey) {
        const key = this.stickyToastKey;
        const action = this.stickyToastActions.get(key) ?? null;
        if (action) {
          try {
            action();
          } catch {
            // ignore
          }
          // If the action didn't replace/clear the sticky toast, clear it now.
          if (this.stickyToastKey === key) {
            this.clearStickyToast(key);
          }
        } else {
          this.clearStickyToast(key);
        }
        return;
      }

      // Non-sticky toast: allow click-to-dismiss.
      const el = this.toastEl;
      if (el) el.classList.remove("isVisible");
      if (this.toastTimer) window.clearTimeout(this.toastTimer);
      this.toastTimer = null;
    };
    inner.addEventListener("click", dismiss);
    inner.addEventListener("keydown", (e) => {
      const ke = e as KeyboardEvent;
      if (ke.key === "Enter" || ke.key === " ") dismiss(e);
    });
    wrap.appendChild(inner);
    document.body.appendChild(wrap);
    this.toastEl = wrap;
    return wrap;
  }

  private showToast(text: string, durationMs: number = 1400): void {
    if (!this.readToastPref()) return;
    const el = this.ensureToastEl();
    if (!el) return;
    const inner = el.firstElementChild as HTMLElement | null;
    if (!inner) return;

    // If a sticky toast is active, temporarily show this toast and then
    // restore the sticky toast after the timer.

    inner.textContent = text;
    if (this.toastTimer) window.clearTimeout(this.toastTimer);

    el.classList.add("isVisible");

    this.toastTimer = window.setTimeout(() => {
      this.toastTimer = null;

      if (this.stickyToastKey && this.stickyToastText) {
        inner.textContent = this.stickyToastText;
        el.classList.add("isVisible");
        return;
      }

      el.classList.remove("isVisible");
    }, Math.max(0, durationMs));
  }

  public showStickyToast(key: string, text: string, opts?: { force?: boolean }): void {
    if (!key) return;
    if (!opts?.force && !this.readToastPref()) return;
    const el = this.ensureToastEl();
    if (!el) return;
    const inner = el.firstElementChild as HTMLElement | null;
    if (!inner) return;

    inner.textContent = text;
    if (this.toastTimer) window.clearTimeout(this.toastTimer);
    this.toastTimer = null;
    el.classList.add("isVisible");
    this.stickyToastKey = key;
    this.stickyToastText = text;
  }

  public setStickyToastAction(key: string, action: (() => void) | null): void {
    if (!key) return;
    if (!action) {
      this.stickyToastActions.delete(key);
      return;
    }
    this.stickyToastActions.set(key, action);
  }

  public clearStickyToast(key: string): void {
    if (!key) return;
    if (this.stickyToastKey !== key) return;
    this.stickyToastKey = null;
    this.stickyToastText = null;

    if (this.toastTimer) window.clearTimeout(this.toastTimer);
    this.toastTimer = null;

    const el = this.toastEl;
    if (el && typeof document !== "undefined" && document.body.contains(el)) {
      el.classList.remove("isVisible");
    }
  }

  private showGameOverToast(message: string): void {
    const msg = typeof message === "string" ? message.trim() : "";
    if (!msg) return;
    if (msg === this.lastGameOverToast) return;
    this.lastGameOverToast = msg;
    this.playSfx("gameOver");
    this.showToast(msg, 3200);
  }

  private maybeToastTurnChange(): void {
    if (this.isGameOver) return;
    if (this.driver.mode === "online") {
      if (this.onlineTransportStatus !== "connected") return;

      // Online play: toast on side-to-move changes (and once on startup), but
      // localize the message using player color when available.
      const toMove = this.state.toMove;
      const shouldToast = this.lastToastToMove === null ? true : this.lastToastToMove !== toMove;
      this.lastToastToMove = toMove;
      if (!shouldToast) return;

      const legal = this.getLegalMovesForTurn();
      const hasCapture = legal.some((m) => m.kind === "capture");

      const localColor = (this.driver as OnlineGameDriver).getPlayerColor();
      if (localColor === "W" || localColor === "B") {
        const isLocalTurn = toMove === localColor;
        if (isLocalTurn) {
          this.showToast(hasCapture ? "Your turn — must capture" : "Your turn", 1500);
          return;
        }
      }

      // If we don't know local color (spectator / reconnect edge), fall back
      // to explicit side-to-move messaging.
      this.showToast(`${toMove === "B" ? "Dark" : "Light"} to ${hasCapture ? "capture" : "move"}`, 1500);
      return;
    }

    // Local play: toast whenever side-to-move changes (and once on startup).
    const toMove = this.state.toMove;
    const shouldToast = this.lastToastToMove === null ? true : this.lastToastToMove !== toMove;
    this.lastToastToMove = toMove;

    if (shouldToast) {
      const legal = this.getLegalMovesForTurn();
      const hasCapture = legal.some((m) => m.kind === "capture");
      this.showToast(`${toMove === "B" ? "Dark" : "Light"} to ${hasCapture ? "capture" : "move"}`, 1500);
    }
  }

  private drawPendingDamaCapturedMarks(): void {
    const rulesetId = this.state.meta?.rulesetId ?? "lasca";
    if (rulesetId !== "dama") return;
    if (this.jumpedSquares.size === 0) return;

    const mode = getDamaCaptureRemovalMode(this.state);
    if (mode !== "end_of_sequence") return;

    for (const over of this.jumpedSquares) {
      // Mark pieces that have been captured but remain on-board until end-of-sequence.
      drawHighlightRing(this.overlayLayer, over, "#ff6b6b", 5);
    }
  }

  private showOpponentConnectionDetailsToast(): void {
    if (this.driver.mode !== "online") return;
    if (typeof document === "undefined") return;
    if (this.isGameOver) return;

    const key = "online_opponent_connection_details";

    // Toggle off if already showing.
    if (this.stickyToastKey === key) {
      this.clearStickyToast(key);
      return;
    }

    // Don't clobber non-online sticky toasts.
    if (this.stickyToastKey && !this.stickyToastKey.startsWith("online_")) return;

    const remote = this.driver as OnlineGameDriver;
    const selfId = remote.getPlayerId();
    const presence = remote.getPresence();
    if (!presence || !selfId || selfId === "spectator") {
      this.setStickyToastAction(key, null);
      this.showStickyToast(key, "Opponent status: —", { force: true });
      return;
    }

    const opponentId = Object.keys(presence).find((pid) => pid !== selfId) ?? null;
    const opp = opponentId ? (presence as any)[opponentId] : null;

    let msg = "Opponent status: Waiting for opponent";
    if (opp) {
      if (opp.connected) {
        msg = "Opponent status: Connected";
      } else if (opp.inGrace && typeof opp.graceUntil === "string") {
        let whenText = opp.graceUntil;
        let remText = "";
        try {
          const untilMs = Date.parse(opp.graceUntil);
          if (Number.isFinite(untilMs)) {
            const d = new Date(untilMs);
            if (!Number.isNaN(d.getTime())) whenText = d.toLocaleTimeString();
            const remMs = Math.max(0, untilMs - Date.now());
            const remS = Math.ceil(remMs / 1000);
            remText = ` (about ${remS}s left)`;
          }
        } catch {
          // ignore
        }
        msg = `Opponent status: Disconnected (grace until ${whenText}${remText})`;
      } else {
        msg = "Opponent status: Disconnected";
      }

      if (typeof opp.lastSeenAt === "string" && opp.lastSeenAt) {
        let lastSeen = opp.lastSeenAt;
        try {
          const d = new Date(opp.lastSeenAt);
          if (!Number.isNaN(d.getTime())) lastSeen = d.toLocaleString();
        } catch {
          // ignore
        }
        msg += `\nLast seen: ${lastSeen}`;
      }
    }

    this.setStickyToastAction(key, null);
    // Force=true because the user explicitly clicked to request this info.
    this.showStickyToast(key, msg, { force: true });
  }

  /**
   * Single render pipeline for authoritative state updates.
   *
   * Ordering contract:
   * 1) render board + pieces
   * 2) draw previews last
   * 3) safety belt: re-append preview-related layers so they stay on top
   */
  private renderAuthoritative(): void {
    // 1) board/pieces
    renderGameState(this.svg, this.piecesLayer, this.inspector, this.state);

    // 2) previews (currently none; kept for move/stack preview rendering)
    // 3) keep preview layers on top (board coords / other layers might be appended later)
    const countsLayer = ensureStackCountsLayer(this.svg);
    this.svg.appendChild(countsLayer);
    this.svg.appendChild(this.previewLayer);
    this.svg.appendChild(this.turnIndicatorLayer);
    this.svg.appendChild(this.opponentPresenceIndicatorLayer);

    this.refreshSelectableCursors();
  }

  private maybeShowReportIssueStickyToast(): void {
    // Back-compat: older builds used a sticky toast for this.
    // Keep the method name to avoid churn, but use a non-sticky, rate-limited hint.
    this.maybeShowReportIssueHintToast();
  }

  private maybeShowReportIssueHintToast(reason?: string): void {
    if (this.driver.mode !== "online") return;
    if (!this.readToastPref()) return;

    // Only show this hint on pages that actually include the "Copy Debug" affordance.
    const copyDebugBtn = document.getElementById("copyDebugBtn") as HTMLButtonElement | null;
    if (!copyDebugBtn) return;

    const remote = this.driver as OnlineGameDriver;
    const roomId = remote.getRoomId();
    if (!roomId) return;

    // Avoid spamming: at most once per room per minute.
    const now = Date.now();
    if (this.reportIssueHintShownForRoomId === roomId && now - this.reportIssueHintLastShownAtMs < 60_000) return;
    this.reportIssueHintShownForRoomId = roomId;
    this.reportIssueHintLastShownAtMs = now;

    const prefix = reason ? `${reason}. ` : "";
    this.showToast(`${prefix}Tip: reporting a bug? Online panel → ⓘ (Copy debug info)`, 4200);
  }

  private clearSelectionForInputLock(): void {
    // Clear only the *interactive* selection/targets.
    // Do NOT clear capture-chain constraints like `lockedCaptureFrom`/`jumpedSquares`,
    // otherwise the same piece can become capturable again during a chain.
    this.selected = null;
    this.currentTargets = [];
    this.currentMoves = [];
    clearOverlays(this.overlayLayer);
    clearPreviewLayer(this.previewLayer);
    this.drawPendingDamaCapturedMarks();
    this.updatePanel();
  }

  private captureDir(fromId: string, toId: string): { dr: number; dc: number } {
    const a = parseNodeId(fromId);
    const b = parseNodeId(toId);
    const dr = Math.sign(b.r - a.r);
    const dc = Math.sign(b.c - a.c);
    return { dr, dc };
  }

  constructor(
    svg: SVGSVGElement,
    piecesLayer: SVGGElement,
    inspector: ReturnType<typeof createStackInspector> | null,
    state: GameState,
    history: HistoryManager,
    driver?: GameDriver
  ) {
    this.svg = svg;
    this.piecesLayer = piecesLayer;
    this.inspector = inspector;
    this.overlayLayer = ensureOverlayLayer(svg);
    this.previewLayer = ensurePreviewLayer(svg);
    this.turnIndicatorLayer = ensureTurnIndicatorLayer(svg);
    this.opponentPresenceIndicatorLayer = ensureOpponentPresenceIndicatorLayer(svg);
    this.state = state;
    this.history = history;
    this.driver = driver ?? new LocalDriver(state, history);
  }

  bind(): void {
    this.svg.addEventListener("click", (ev) => this.onClick(ev));

    // In online mode, the RemoteDriver may have already applied a server snapshot
    // during startup (create/join/resume). Sync controller state to the driver so
    // the board and history panel are consistent immediately.
    if (this.driver.mode === "online") {
      this.state = this.driver.getState();
      this.renderAuthoritative();
    }

    // Check for mandatory captures at game start
    const allLegal = generateLegalMoves(this.state);
    this.mandatoryCapture = allLegal.length > 0 && allLegal[0].kind === "capture";
    this.recomputeRepetitionCounts();
    this.updatePanel();
    this.refreshSelectableCursors();

    // If we entered an already-ended room, show the end-game status immediately.
    // This covers both server-forced end states and normal terminal positions.
    if (!this.isGameOver) {
      const forcedMsg = (this.state as any)?.forcedGameOver?.message as string | undefined;
      if (typeof forcedMsg === "string" && forcedMsg.trim()) {
        this.isGameOver = true;
        this.clearSelection();
        this.showBanner(forcedMsg, 0);
        this.showGameOverToast(forcedMsg);
        this.updatePanel();
        this.fireHistoryChange("gameOver");
      } else {
        this.checkAndHandleCurrentPlayerLost();
      }
    }

    // Initialize and (optionally) show a turn toast at startup.
    if (!this.isGameOver) {
      this.lastToastToMove = null;
      this.maybeToastTurnChange();
    }

    this.bindRoomIdCopyButton();
    this.bindWatchLinkCopyButton();
    this.bindDebugCopyButton();
    this.bindReplayButton();

    this.startOnlinePolling();
  }

  private isBlockedByDisconnectedOpponent(): boolean {
    if (this.driver.mode !== "online") return false;
    try {
      const remote = this.driver as OnlineGameDriver;
      const selfId = remote.getPlayerId();
      const presence = remote.getPresence();
      if (presence && selfId && selfId !== "spectator") {
        const opponentId = Object.keys(presence).find((pid) => pid !== selfId) ?? null;
        const opp = opponentId ? (presence as any)[opponentId] : null;
        return Boolean(opp && opp.connected === false);
      }
    } catch {
      // If presence isn't available, don't block.
    }
    return false;
  }

  private refreshSelectableCursors(): void {
    // Clear any previous markings that we applied.
    for (const nodeId of this.cursorMarkedSelectableStacks) {
      const g = this.piecesLayer.querySelector(`g.stack[data-node="${nodeId}"]`) as SVGGElement | null;
      if (g && g.getAttribute("data-cursor") === "selectable") {
        g.style.cursor = "";
        g.removeAttribute("data-cursor");
      }
    }
    this.cursorMarkedSelectableStacks.clear();

    for (const nodeId of this.cursorMarkedTargets) {
      const el = document.getElementById(nodeId) as SVGElement | null;
      if (el && el.getAttribute("data-cursor") === "target") {
        (el as any).style.cursor = "";
        el.removeAttribute("data-cursor");
      }
    }
    this.cursorMarkedTargets.clear();

    // Only show the pointer cursor when input is actually meaningful.
    if (this.isGameOver) return;
    if (!this.inputEnabled) return;
    if (!this.isLocalPlayersTurn()) return;
    if (this.isBlockedByDisconnectedOpponent()) return;

    const legal = this.getLegalMovesForTurn();
    const selectableFrom = new Set<string>(
      legal.map((m) => (m as any).from).filter((v) => typeof v === "string") as string[]
    );

    for (const fromId of selectableFrom) {
      const g = this.piecesLayer.querySelector(`g.stack[data-node="${fromId}"]`) as SVGGElement | null;
      if (!g) continue;
      g.style.cursor = "pointer";
      g.setAttribute("data-cursor", "selectable");
      this.cursorMarkedSelectableStacks.add(fromId);
    }

    // When a piece is selected, also show a pointer over its legal destination squares.
    if (this.selected && this.currentTargets.length) {
      for (const toId of this.currentTargets) {
        const el = document.getElementById(toId) as SVGElement | null;
        if (!el) continue;
        (el as any).style.cursor = "pointer";
        el.setAttribute("data-cursor", "target");
        this.cursorMarkedTargets.add(toId);
      }
    }
  }

  /**
   * Theme switching can change which piece symbol IDs exist (e.g. Wooden variants).
   * Re-render the authoritative view so all <use href="#..."></use> references match the active theme.
   */
  refreshForThemeChange(): void {
    if (this.isGameOver) {
      // Still refresh so the final position renders under the new theme.
      this.renderAuthoritative();
      this.updatePanel();
      return;
    }

    this.renderAuthoritative();
    this.updatePanel();
  }

  setMoveHints(enabled: boolean): void {
    this.moveHintsEnabled = enabled;
    // If we have a selection, refresh it to show/hide hints
    if (this.selected) {
      this.showSelection(this.selected);
    }
  }

  setAnimations(enabled: boolean): void {
    this.animationsEnabled = enabled;
  }

  setHistoryChangeCallback(callback: (reason: HistoryChangeReason) => void): void {
    this.historyListeners = [callback];
  }

  addHistoryChangeCallback(callback: (reason: HistoryChangeReason) => void): void {
    this.historyListeners.push(callback);
  }

  private checkAndHandleCurrentPlayerLost(): boolean {
    const result = checkCurrentPlayerLost(this.state);
    if (result.winner) {
      if (this.isGameOver) return true;
      this.isGameOver = true;
      this.clearSelection();
      const msg = result.reason || "Game Over";
      this.showBanner(msg, 0);
      this.showGameOverToast(msg);
      this.updatePanel();
      this.fireHistoryChange("gameOver");
      return true;
    }
    return false;
  }

  private fireHistoryChange(reason: HistoryChangeReason): void {
    for (const cb of this.historyListeners) {
      try {
        cb(reason);
      } catch (err) {
        // eslint-disable-next-line no-console
        console.error("[controller] history listener error", err);
      }
    }
  }

  isOver(): boolean {
    return this.isGameOver;
  }

  showStartupMessage(message: string): void {
    const msg = typeof message === "string" ? message.trim() : "";
    if (!msg) return;

    try {
      const elMsg = document.getElementById("statusMessage");
      if (elMsg) elMsg.textContent = msg;
    } catch {
      // ignore
    }

    // Toast is preference-gated inside showToast.
    this.showToast(msg, 3200);
  }

  setInputEnabled(enabled: boolean): void {
    const wasEnabled = this.lastInputEnabled;
    this.lastInputEnabled = enabled;
    this.inputEnabled = enabled;
    if (!enabled) {
      // Avoid leaving stale selection overlays when AI is running.
      this.clearSelectionForInputLock();
      // Also clear any pointer cursor hints while input is locked.
      this.refreshSelectableCursors();
      return;
    }

    // Local play: AI often disables input while thinking. When input returns,
    // show a prominent toast indicating who is up next.
    if (!wasEnabled && !this.isGameOver && this.driver.mode !== "online") {
      this.lastToastToMove = null;
      this.maybeToastTurnChange();
    }

    // Input re-enabled: re-apply cursor hints immediately.
    this.refreshSelectableCursors();
  }

  getCaptureChainConstraints(): {
    lockedCaptureFrom: string | null;
    lockedCaptureDir: { dr: number; dc: number } | null;
    jumpedSquares: string[];
  } {
    return {
      lockedCaptureFrom: this.lockedCaptureFrom,
      lockedCaptureDir: this.lockedCaptureDir,
      jumpedSquares: Array.from(this.jumpedSquares),
    };
  }

  getLegalMovesForTurn(): Move[] {
    const rulesetId = this.state.meta?.rulesetId ?? "lasca";
    const captureRemoval = rulesetId === "dama" ? getDamaCaptureRemovalMode(this.state) : null;
    // All rulesets with multi-capture chains must prevent re-jumping the same square.
    const isDamasca = rulesetId === "damasca" || rulesetId === "damasca_classic";
    const chainRules = rulesetId === "lasca" || rulesetId === "dama" || isDamasca;
    // Only Dama/Damasca have capture-direction constraints (Officer zigzag).
    const chainHasDir = rulesetId === "dama" || isDamasca;
    const constraints = this.lockedCaptureFrom
      ? {
          forcedFrom: this.lockedCaptureFrom,
          ...(chainRules
            ? {
                excludedJumpSquares: this.jumpedSquares,
                ...(chainHasDir ? { lastCaptureDir: this.lockedCaptureDir ?? undefined } : {}),
              }
            : {}),
        }
      : undefined;
    const allLegal = generateLegalMoves(this.state, constraints);

    if (this.lockedCaptureFrom) {
      return allLegal.filter((m) => m.kind === "capture");
    }

    return allLegal;
  }

  async playMove(move: Move): Promise<void> {
    if (this.isGameOver) return;

    // Ensure move is still legal under the current turn constraints.
    const legal = this.getLegalMovesForTurn();
    const same = (a: Move, b: Move) => {
      if (a.kind !== b.kind) return false;
      if (a.from !== (b as any).from || (a as any).to !== (b as any).to) return false;
      if (a.kind === "capture") return (a as any).over === (b as any).over;
      return true;
    };
    if (!legal.some((m) => same(m, move))) return;

    await this.applyChosenMove(move);
  }

  undo(): void {
    const prevState = this.driver.undo();
    if (prevState) {
      this.playSfx("undo");
      // Allow undoing out of terminal states.
      this.isGameOver = false;

      // Cancel any transient UI timers from the previous position.
      if (this.bannerTimer) {
        window.clearTimeout(this.bannerTimer);
        this.bannerTimer = null;
      }
      if (this.remainderTimer) {
        window.clearTimeout(this.remainderTimer);
        this.remainderTimer = null;
      }

      this.state = prevState;
      this.lockedCaptureFrom = null;
      this.lockedCaptureDir = null;
      this.jumpedSquares.clear();
      this.currentTurnNodes = [];
      this.currentTurnHasCapture = false;
      this.clearSelection();
      this.renderAuthoritative();
      const allLegal = generateLegalMoves(this.state);
      this.mandatoryCapture = allLegal.length > 0 && allLegal[0].kind === "capture";
      this.updatePanel();
      this.recomputeRepetitionCounts();
      this.checkAndHandleCurrentPlayerLost();
      this.maybeToastTurnChange();
      this.fireHistoryChange("undo");
    }
  }

  redo(): void {
    const nextState = this.driver.redo();
    if (nextState) {
      this.playSfx("redo");
      // Allow redoing out of terminal states.
      this.isGameOver = false;

      // Cancel any transient UI timers from the previous position.
      if (this.bannerTimer) {
        window.clearTimeout(this.bannerTimer);
        this.bannerTimer = null;
      }
      if (this.remainderTimer) {
        window.clearTimeout(this.remainderTimer);
        this.remainderTimer = null;
      }

      this.state = nextState;
      this.lockedCaptureFrom = null;
      this.lockedCaptureDir = null;
      this.jumpedSquares.clear();
      this.currentTurnNodes = [];
      this.currentTurnHasCapture = false;
      this.clearSelection();
      this.renderAuthoritative();
      const allLegal = generateLegalMoves(this.state);
      this.mandatoryCapture = allLegal.length > 0 && allLegal[0].kind === "capture";
      this.updatePanel();
      this.recomputeRepetitionCounts();
      this.checkAndHandleCurrentPlayerLost();
      this.maybeToastTurnChange();
      this.fireHistoryChange("redo");
    }
  }

  jumpToHistory(index: number): void {
    const target = this.driver.jumpToHistory(index);
    if (!target) return;

    // Allow jumping out of terminal states.
    this.isGameOver = false;

    // Cancel any transient UI timers.
    if (this.bannerTimer) {
      window.clearTimeout(this.bannerTimer);
      this.bannerTimer = null;
    }
    if (this.remainderTimer) {
      window.clearTimeout(this.remainderTimer);
      this.remainderTimer = null;
    }

    this.state = target;
    this.lockedCaptureFrom = null;
    this.lockedCaptureDir = null;
    this.jumpedSquares.clear();
    this.currentTurnNodes = [];
    this.currentTurnHasCapture = false;
    this.clearSelection();
    this.renderAuthoritative();
    const allLegal = generateLegalMoves(this.state);
    this.mandatoryCapture = allLegal.length > 0 && allLegal[0].kind === "capture";
    this.updatePanel();
    this.recomputeRepetitionCounts();
    this.checkAndHandleCurrentPlayerLost();
    this.maybeToastTurnChange();
    this.fireHistoryChange("jump");
  }

  canUndo(): boolean {
    return this.driver.canUndo();
  }

  canRedo(): boolean {
    return this.driver.canRedo();
  }

  getHistory(): ReturnType<HistoryManager["getHistory"]> {
    return this.driver.getHistory();
  }

  exportMoveHistory(): string {
    const historyData = this.driver.getHistory();
    const moves = historyData
      .filter((entry, idx) => idx > 0 && entry.notation) // Skip "Start" and entries without notation
      .map((entry, idx) => {
        const playerWhoMoved = entry.toMove === "B" ? "Light" : "Dark";
        const moveNum = playerWhoMoved === "Dark"
          ? Math.ceil((idx + 1) / 2) 
          : Math.floor((idx + 2) / 2);
        return {
          moveNumber: moveNum,
          player: playerWhoMoved,
          notation: entry.notation,
        };
      });

    return JSON.stringify({
      game: "Lasca",
      date: new Date().toISOString(),
      moves: moves,
    }, null, 2);
  }

  setState(next: GameState): void {
    const prev = this.state;
    const prevWasGameOver = this.isGameOver;

    this.state = next;
    this.driver.setState(next);

    // Online snapshots (and other external pushes) should sound like the game is alive.
    // Only attempt when we have a real prior state.
    try {
      const didTurnFlip = prev?.toMove !== next.toMove;
      const didForcedOverAppear = Boolean((next as any)?.forcedGameOver) && !Boolean((prev as any)?.forcedGameOver);
      if (!prevWasGameOver && (didForcedOverAppear || didTurnFlip)) {
        this.playSfx(this.inferMoveSfx(prev, next));
      }
    } catch {
      // ignore
    }
    
    // When loading a game, check if the current player has already lost
    const currentPlayerResult = checkCurrentPlayerLost(this.state);
    if (currentPlayerResult.winner) {
      this.isGameOver = true;
      const msg = currentPlayerResult.reason || "Game Over";
      this.playSfx("gameOver");
      this.showBanner(msg, 0);
      this.showGameOverToast(msg);
      this.updatePanel();
      return;
    }
    
    // Game is not over, reset the flag
    this.isGameOver = false;

    // Recompute repetition counts from current history (if any).
    this.recomputeRepetitionCounts();
    
    // Check if captures are available for the current player
    const allLegal = generateLegalMoves(this.state);
    this.mandatoryCapture = allLegal.length > 0 && allLegal[0].kind === "capture";
    this.updatePanel();

    this.maybeToastTurnChange();
  }

  getState(): GameState {
    return this.state;
  }

  async resign(): Promise<void> {
    if (this.isGameOver) return;

    if (this.driver.mode === "online") {
      try {
        const next = await (this.driver as OnlineGameDriver).resignRemote();
        // Clear selection/overlays even if setState exits early on game-over.
        this.clearSelection();
        this.setState(next);
      } catch (err) {
        // eslint-disable-next-line no-console
        console.error("[controller] resign failed", err);
        const msg = err instanceof Error ? err.message : "Resign failed";
        this.showBanner(msg, 1500);
      }
      return;
    }

    // Local: current player resigns, so the other player wins
    const winner = this.state.toMove === "B" ? "W" : "B";
    const winnerName = winner === "B" ? "Dark" : "Light";
    const loserName = this.state.toMove === "B" ? "Dark" : "Light";

    this.isGameOver = true;
    this.clearSelection();
    const msg = `${loserName} resigned — ${winnerName} wins!`;
    this.showBanner(msg, 0);
    this.showGameOverToast(msg);
  }

  newGame(initialState: GameState): void {
    // Clear history and start fresh
    this.driver.clearHistory();
    this.driver.pushHistory(initialState);
    
    // Reset game state
    this.state = initialState;
    this.driver.setState(initialState);
    this.isGameOver = false;
    this.clearSelection();

    this.recomputeRepetitionCounts();
    
    // Re-render the board
    this.renderAuthoritative();
    
    // Check for mandatory captures at game start
    const allLegal = generateLegalMoves(this.state);
    this.mandatoryCapture = allLegal.length > 0 && allLegal[0].kind === "capture";
    this.updatePanel();

    // Always re-toast at new game start.
    this.lastToastToMove = null;
    this.maybeToastTurnChange();
    
    // Notify history change
    this.fireHistoryChange("newGame");
  }

  loadGame(
    loadedState: GameState,
    historyData?: { states: GameState[]; notation: string[]; currentIndex: number }
  ): void {
    if (historyData && historyData.states && historyData.states.length > 0) {
      this.driver.replaceHistory(historyData);
    } else {
      // Reset history and start fresh with loaded state
      this.driver.clearHistory();
      this.driver.pushHistory(loadedState);
    }
    
    // Reset game state to idle phase; prefer aligning to the restored history's current state.
    const currentFromHistory = this.driver.getHistoryCurrent();
    const baseState = currentFromHistory ?? loadedState;
    this.isGameOver = false;
    this.state = { ...baseState, phase: "idle" };
    this.driver.setState(this.state);
    
    // Clear any selection, overlays, and capture state
    this.clearSelection();
    
    // Re-render the board
    this.renderAuthoritative();
    
    // Recompute mandatory captures
    const allLegal = generateLegalMoves(this.state);
    this.mandatoryCapture = allLegal.length > 0 && allLegal[0].kind === "capture";
    this.updatePanel();

    this.recomputeRepetitionCounts();

    // If the loaded position is already terminal for the player to move, end immediately.
    this.checkAndHandleCurrentPlayerLost();

    // Always re-toast after load.
    this.lastToastToMove = null;
    this.maybeToastTurnChange();
    
    // Notify history change
    this.fireHistoryChange("loadGame");
  }

  private updatePanel(): void {
    const elTurn = document.getElementById("statusTurn");
    const elPhase = document.getElementById("statusPhase");
    const elMsg = document.getElementById("statusMessage");
    const elDeadPlayTimer =
      (document.getElementById("statusDeadPlayTimer") as HTMLElement | null) ??
      (document.getElementById("statusLoneKingTimer") as HTMLElement | null);
    const elOnlineInfoPanel = document.getElementById("onlineInfoPanel") as HTMLElement | null;
    const elRoomId = document.getElementById("infoRoomId");
    const elCopy = document.getElementById("copyRoomIdBtn") as HTMLButtonElement | null;
    const elCopyWatch = document.getElementById("copyWatchLinkBtn") as HTMLButtonElement | null;
    const elCopyDebug = document.getElementById("copyDebugBtn") as HTMLButtonElement | null;
    const elOpponent = document.getElementById("onlineOpponentStatus") as HTMLDivElement | null;
    const elReplayBtn = document.getElementById("openReplayBtn") as HTMLButtonElement | null;
    const elNewGame = document.getElementById("newGameBtn") as HTMLButtonElement | null;
    const elLoadGame = document.getElementById("loadGameBtn") as HTMLButtonElement | null;
    const elLoadGameInput = document.getElementById("loadGameInput") as HTMLInputElement | null;
    const isOnline = this.driver.mode === "online";

    // Online UX: when a room is newly created and we're waiting for the opponent,
    // show a sticky toast offering to copy an invite link.
    // Call early so it still runs even if we early-return while setting status text.
    this.maybeShowOnlineWaitingInviteToast();

    if (elOnlineInfoPanel) elOnlineInfoPanel.hidden = !isOnline;

    if (elReplayBtn) elReplayBtn.disabled = !(isOnline && this.isGameOver);

    if (elCopyWatch) {
      if (!isOnline) {
        elCopyWatch.disabled = true;
      } else {
        const pid = (this.driver as OnlineGameDriver).getPlayerId();
        elCopyWatch.disabled = !pid || pid === "spectator";
      }
    }

    if (elNewGame) elNewGame.disabled = isOnline;
    if (elLoadGame) elLoadGame.disabled = isOnline;
    if (elLoadGameInput) elLoadGameInput.disabled = isOnline;

    if (elTurn) elTurn.textContent = this.state.toMove === "B" ? "Dark" : "Light";
    if (elPhase) elPhase.textContent = this.isGameOver ? "Game Over" : (this.selected ? "Select" : "Idle");

    // Board HUD: show whose turn it is as a small icon in the board's upper-left.
    const toMoveLabel = this.state.toMove === "W" ? "Light" : "Dark";
    let turnTooltipText: string | undefined = `${toMoveLabel} to move`;
    if (this.driver.mode === "online") {
      const remote = this.driver as OnlineGameDriver;
      const selfId = remote.getPlayerId();
      const localColor = remote.getPlayerColor();

      if ((localColor === "W" || localColor === "B") && selfId && selfId !== "spectator") {
        const youLabel = localColor === "W" ? "Light" : "Dark";
        const yourTurnText = this.state.toMove === localColor ? "your turn" : `${toMoveLabel} to move`;
        turnTooltipText = `You are ${youLabel} — ${yourTurnText}`;
      }
    }

    renderTurnIndicator(this.svg, this.turnIndicatorLayer, this.state.toMove, {
      hidden: this.isGameOver,
      tooltipText: turnTooltipText,
    });

    // Board HUD: show opponent presence under the turn indicator.
    if (this.driver.mode !== "online" || this.isGameOver) {
      renderOpponentPresenceIndicator(this.svg, this.opponentPresenceIndicatorLayer, {
        opponentColor: "B",
        status: "waiting",
        hidden: true,
      });
    } else {
      const remote = this.driver as OnlineGameDriver;
      const selfId = remote.getPlayerId();
      const presence = remote.getPresence();
      const localColor = remote.getPlayerColor();

      const opponentColor = localColor === "B" ? "W" : "B";

      let status: "connected" | "in_grace" | "disconnected" | "waiting" = "waiting";
      let graceUntil: string | null = null;

      if (!presence || !selfId || selfId === "spectator") {
        status = "waiting";
      } else {
        const opponentId = Object.keys(presence).find((pid) => pid !== selfId) ?? null;
        const opp = opponentId ? (presence as any)[opponentId] : null;

        if (!opp) {
          status = "waiting";
        } else if (opp.connected) {
          status = "connected";
        } else if (opp.inGrace) {
          status = "in_grace";
          graceUntil = typeof opp.graceUntil === "string" ? opp.graceUntil : null;
          if (graceUntil) {
            try {
              const d = new Date(graceUntil);
              if (!Number.isNaN(d.getTime())) graceUntil = d.toLocaleTimeString();
            } catch {
              // ignore
            }
          }
        } else {
          status = "disconnected";
        }
      }

      renderOpponentPresenceIndicator(this.svg, this.opponentPresenceIndicatorLayer, {
        opponentColor,
        status,
        graceUntil,
        hidden: false,
      });
    }

    // Allow clicking the opponent status in either the panel row or the board HUD icon.
    if (!this.didBindOpponentStatusClicks && typeof document !== "undefined") {
      this.didBindOpponentStatusClicks = true;

      const elOpponentStatus = document.getElementById("onlineOpponentStatus") as HTMLDivElement | null;
      if (elOpponentStatus) {
        elOpponentStatus.style.cursor = "pointer";
        elOpponentStatus.title = "Show opponent connection details";
        elOpponentStatus.addEventListener("click", () => this.showOpponentConnectionDetailsToast());
      }

      // SVG HUD icon.
      try {
        this.opponentPresenceIndicatorLayer.addEventListener("click", (e) => {
          e.preventDefault();
          e.stopPropagation();
          this.showOpponentConnectionDetailsToast();
        });
      } catch {
        // ignore
      }
    }

    if (elDeadPlayTimer) {
      const rulesetId = this.state.meta?.rulesetId ?? "lasca";
      const isDamasca = rulesetId === "damasca" || rulesetId === "damasca_classic";
      const dp = (this.state as any).damascaDeadPlay as
        | { noProgressPlies?: number; officerOnlyPlies?: number }
        | undefined;
      if (isDamasca && dp) {
        const np = Math.max(0, Math.floor(dp.noProgressPlies ?? 0));
        const oo = Math.max(0, Math.floor(dp.officerOnlyPlies ?? 0));
        const npRem = Math.max(0, DAMASCA_NO_PROGRESS_LIMIT_PLIES - np);
        const ooRem = Math.max(0, DAMASCA_OFFICER_ONLY_LIMIT_PLIES - oo);

        elDeadPlayTimer.textContent = `No-progress: ${npRem} plies left • Officer-only: ${ooRem} plies left`;

        // Prominent warning banner when either counter gets low.
        // Trigger at 20/10/5 plies remaining to avoid spam.
        if (!this.isGameOver && this.onlineTransportStatus === "connected") {
          const thresholds = new Set([20, 10, 5]);
          const warnings: string[] = [];
          if (thresholds.has(npRem)) {
            warnings.push(
              `Dead-play warning: no-progress counter reaches 0 in ${npRem} plies (game ends; adjudicated)`
            );
          }
          if (thresholds.has(ooRem)) {
            warnings.push(
              `Dead-play warning: officer-only counter reaches 0 in ${ooRem} plies (game ends; adjudicated)`
            );
          }

          // Reset warning memory once we're safely out of the warning zone.
          if (npRem > 20 && ooRem > 20) this.lastDeadPlayWarning = null;

          const msg = warnings.join(" • ");
          if (msg && msg !== this.lastDeadPlayWarning) {
            this.lastDeadPlayWarning = msg;
            this.showBanner(msg, 2500);
            this.showToast(msg, 2600);
          }
        }
      } else {
        elDeadPlayTimer.textContent = "—";
      }
    }
    if (elRoomId) {
      if (this.driver.mode === "online") {
        const roomId = (this.driver as OnlineGameDriver).getRoomId();
        elRoomId.textContent = roomId ?? "—";
        if (elCopy) elCopy.disabled = !roomId;
        if (elCopyDebug) elCopyDebug.disabled = !roomId;
      } else {
        elRoomId.textContent = "—";
        if (elCopy) elCopy.disabled = true;
        if (elCopyDebug) elCopyDebug.disabled = true;
      }
    } else {
      if (elCopy) elCopy.disabled = true;
      if (elCopyDebug) elCopyDebug.disabled = true;
    }

    if (elOpponent) {
      if (this.driver.mode !== "online") {
        elOpponent.textContent = "—";
      } else {
        const remote = this.driver as OnlineGameDriver;
        const selfId = remote.getPlayerId();
        const presence = remote.getPresence();

        if (!presence || !selfId || selfId === "spectator") {
          elOpponent.textContent = selfId === "spectator" ? "Spectating" : "—";
        } else {
          const opponentId = Object.keys(presence).find((pid) => pid !== selfId) ?? null;
          const opp = opponentId ? (presence as any)[opponentId] : null;

          this.maybeToastOpponentPresence({ selfId, opponentId, opp });

          if (!opp) {
            elOpponent.textContent = "Waiting for opponent";
          } else if (opp.inGrace && typeof opp.graceUntil === "string") {
            let when = opp.graceUntil;
            try {
              const d = new Date(opp.graceUntil);
              if (!Number.isNaN(d.getTime())) when = d.toLocaleTimeString();
            } catch {
              // ignore
            }
            elOpponent.textContent = `Disconnected (grace until ${when})`;
          } else if (opp.connected) {
            elOpponent.textContent = "Connected";
          } else {
            elOpponent.textContent = "Disconnected";
          }
        }
      }
    }
    if (elMsg && !this.isGameOver) {
      if (isOnline && this.onlineTransportStatus === "reconnecting") {
        elMsg.textContent = "Reconnecting…";
        return;
      }

      if (isOnline) {
        const remote = this.driver as OnlineGameDriver;
        const selfId = remote.getPlayerId();
        const localColor = remote.getPlayerColor();
        if (!selfId || selfId === "spectator") {
          elMsg.textContent = "Spectating";
          return;
        }
        if (!localColor) {
          elMsg.textContent = "Waiting for seat assignment";
          return;
        }
        if (!this.onlineHasOpponent()) {
          elMsg.textContent = "Waiting for opponent to join";
          return;
        }
        if (this.state.toMove !== localColor) {
          elMsg.textContent = "Opponent's turn";
          return;
        }
      }
      if (this.selected) {
        if (this.currentTargets.length > 0) {
          if (this.lockedCaptureFrom) {
            elMsg.textContent = "Continue capturing";
          } else {
            elMsg.textContent = "Choose a destination";
          }
        } else if (this.mandatoryCapture) {
          elMsg.textContent = "Capture required — select a capturing stack";
        } else {
          elMsg.textContent = "No moves";
        }
      } else {
        // No selection - check if captures are mandatory
        if (this.mandatoryCapture) {
          elMsg.textContent = "Capture available — you must capture";
        } else {
          elMsg.textContent = "—";
        }
      }
    }

  }

  private maybeToastOpponentPresence(args: { selfId: string | null; opponentId: string | null; opp: any | null }): void {
    if (this.driver.mode !== "online") {
      this.lastOpponentPresent = null;
      this.lastOpponentConnected = null;
      this.clearStickyToast("online_opponent_presence");
      return;
    }
    if (this.isGameOver) return;

    const selfId = args.selfId;
    if (!selfId || selfId === "spectator") {
      this.lastOpponentPresent = null;
      this.lastOpponentConnected = null;
      this.clearStickyToast("online_opponent_presence");
      return;
    }

    const opponentPresent = Boolean(args.opp);
    const opponentConnected = opponentPresent ? Boolean(args.opp.connected) : null;
    const hadEverOpponent = this.everSawOpponentPresent;

    // Prime state without showing any toasts.
    if (this.lastOpponentPresent === null && this.lastOpponentConnected === null) {
      this.lastOpponentPresent = opponentPresent;
      this.lastOpponentConnected = opponentConnected;
      return;
    }

    const key = "online_opponent_presence";

    // Opponent no longer in room (seat missing).
    if (this.lastOpponentPresent === true && opponentPresent === false) {
      this.showStickyToast(key, "Opponent left the room");
      this.maybeShowReportIssueHintToast("Opponent left");
    }

    // Opponent (re)joins the room (seat appears).
    if (this.lastOpponentPresent === false && opponentPresent === true) {
      // If we already had an opponent earlier, treat this as a rejoin.
      // Otherwise, it is the initial join for a newly-created room.
      const msg = hadEverOpponent ? "Opponent rejoined" : "Opponent joined";
      this.clearStickyToast(key);
      this.showToast(msg, 1800);
    }

    // Opponent disconnected (still in room but not connected).
    if (this.lastOpponentConnected === true && opponentPresent && opponentConnected === false) {
      let msg = "Opponent disconnected";

      if (args.opp?.inGrace && typeof args.opp?.graceUntil === "string") {
        let when = args.opp.graceUntil;
        try {
          const d = new Date(args.opp.graceUntil);
          if (!Number.isNaN(d.getTime())) when = d.toLocaleTimeString();
        } catch {
          // ignore
        }
        msg = `Opponent disconnected (grace until ${when})`;
      }

      this.showStickyToast(key, msg);
      this.maybeShowReportIssueHintToast("Opponent disconnected");
    }

    // Opponent rejoined.
    if (this.lastOpponentConnected === false && opponentPresent && opponentConnected === true) {
      this.clearStickyToast(key);
      this.showToast("Opponent rejoined", 1800);
    }

    this.lastOpponentPresent = opponentPresent;
    this.lastOpponentConnected = opponentConnected;
    if (opponentPresent) this.everSawOpponentPresent = true;
  }

  private resolveClickedNode(target: EventTarget | null): string | null {
    // If clicking a rendered stack, read data-node from closest g.stack
    if (target && target instanceof Element) {
      // First, if the target (or ancestor) has data-node, prefer that
      const withData = target.closest("[data-node]") as Element | null;
      if (withData) {
        const id = withData.getAttribute("data-node");
        if (id) return id;
      }
      const stack = target.closest("g.stack") as SVGGElement | null;
      if (stack) {
        const id = stack.getAttribute("data-node");
        if (id) return id;
      }
      // Else if clicking a circle node
      if (target instanceof SVGCircleElement) {
        const id = target.getAttribute("id");
        if (id) return id;
      }
    }
    return null;
  }

  private svgPointFromClient(ev: MouseEvent): { x: number; y: number } {
    const pt = (this.svg as any).createSVGPoint ? (this.svg as any).createSVGPoint() : null;
    if (pt && this.svg.getScreenCTM) {
      pt.x = ev.clientX;
      pt.y = ev.clientY;
      const m = this.svg.getScreenCTM();
      if (m && (m as any).inverse) {
        const p = pt.matrixTransform((m as any).inverse());
        return { x: p.x, y: p.y };
      }
    }
    // Fallback: approximate using bounding rect
    const rect = this.svg.getBoundingClientRect();
    return { x: ev.clientX - rect.left, y: ev.clientY - rect.top };
  }

  private hitTestTargets(ev: MouseEvent): string | null {
    if (!this.selected || this.currentTargets.length === 0) return null;
    const { x, y } = this.svgPointFromClient(ev);
    for (const id of this.currentTargets) {
      const circle = document.getElementById(id) as SVGCircleElement | null;
      if (!circle) continue;
      const cx = parseFloat(circle.getAttribute("cx") || "0");
      const cy = parseFloat(circle.getAttribute("cy") || "0");
      const r = parseFloat(circle.getAttribute("r") || "0");
      const dx = x - cx;
      const dy = y - cy;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist <= r + 12) return id; // within target ring radius
    }
    return null;
  }

  private isOwnStack(nodeId: string): boolean {
    const stack = this.state.board.get(nodeId);
    if (!stack || stack.length === 0) return false;
    const top = stack[stack.length - 1];
    return top.owner === this.state.toMove;
  }

  private recomputeRepetitionCounts(): void {
    this.repetitionCounts.clear();
    const isDamasca =
      (this.state.meta?.rulesetId ?? "lasca") === "damasca" ||
      (this.state.meta?.rulesetId ?? "lasca") === "damasca_classic";
    if (!RULES.drawByThreefold && !isDamasca) return;

    const snap = this.driver.exportHistorySnapshots();
    const states = snap.states;
    const end = snap.currentIndex;
    for (let i = 0; i <= end && i < states.length; i++) {
      const h = hashGameState(states[i]);
      this.repetitionCounts.set(h, (this.repetitionCounts.get(h) || 0) + 1);
    }
  }

  private recordRepetitionForCurrentState(): boolean {
    const isDamasca =
      (this.state.meta?.rulesetId ?? "lasca") === "damasca" ||
      (this.state.meta?.rulesetId ?? "lasca") === "damasca_classic";
    if (!RULES.drawByThreefold && !isDamasca) return false;
    const h = hashGameState(this.state);
    const next = (this.repetitionCounts.get(h) || 0) + 1;
    this.repetitionCounts.set(h, next);
    return next >= 3;
  }

  private checkThreefoldRepetition(): boolean {
    const isDamasca =
      (this.state.meta?.rulesetId ?? "lasca") === "damasca" ||
      (this.state.meta?.rulesetId ?? "lasca") === "damasca_classic";
    if (!RULES.drawByThreefold && !isDamasca) return false;
    const h = hashGameState(this.state);
    return (this.repetitionCounts.get(h) || 0) >= 3;
  }

  private showSelection(nodeId: string): void {
    clearOverlays(this.overlayLayer);
    drawSelection(this.overlayLayer, nodeId);
    const allLegal = generateLegalMoves(
      this.state,
      this.lockedCaptureFrom
        ? { forcedFrom: this.lockedCaptureFrom, excludedJumpSquares: this.jumpedSquares }
        : undefined
    );
    this.mandatoryCapture = allLegal.length > 0 && allLegal[0].kind === "capture";
    
    // If in a capture chain, only allow moves from the locked position
    let movesForNode = allLegal.filter(m => m.from === nodeId);
    if (this.lockedCaptureFrom && this.lockedCaptureFrom !== nodeId) {
      movesForNode = [];
    }
    
    this.currentMoves = movesForNode;
    this.currentTargets = this.currentMoves.map(m => m.to);
    drawTargets(this.overlayLayer, this.currentTargets);

    // Dama International (end-of-sequence capture removal): visually mark already-captured pieces
    // that are pending removal so the player understands they cannot be jumped again.
    this.drawPendingDamaCapturedMarks();
    
    // Draw move hints if enabled
    if (this.moveHintsEnabled) {
      for (const move of this.currentMoves) {
        if (move.kind === "capture") {
          // Red circle for the piece being jumped over
          drawHighlightRing(this.overlayLayer, move.over, "#ff6b6b", 3);
          // Orange circle for the landing square (target)
          drawHighlightRing(this.overlayLayer, move.to, "#ff9f40", 4);
        }
      }
    }
    
    this.updatePanel();
    this.refreshSelectableCursors();
    if (import.meta.env && import.meta.env.DEV) {
      // eslint-disable-next-line no-console
      console.log("[controller] select", nodeId, { targets: this.currentTargets });
    }
  }

  private clearSelection(): void {
    this.selected = null;
    this.currentTargets = [];
    this.currentMoves = [];
    // Recalculate mandatory capture based on current state, don't just set to false
    const allLegal = generateLegalMoves(this.state);
    this.mandatoryCapture = allLegal.length > 0 && allLegal[0].kind === "capture";
    this.lockedCaptureFrom = null;
    this.lockedCaptureDir = null;
    this.jumpedSquares.clear();
    clearOverlays(this.overlayLayer);
    clearPreviewLayer(this.previewLayer);
    this.updatePanel();
    this.refreshSelectableCursors();
  }

  private showBanner(text: string, durationMs: number = 1500): void {
    const elMsg = document.getElementById("statusMessage");
    if (elMsg) elMsg.textContent = text;
    if (this.bannerTimer) window.clearTimeout(this.bannerTimer);
    
    // If durationMs is 0 or less, keep the banner permanently (for game over)
    if (durationMs > 0) {
      this.bannerTimer = window.setTimeout(() => {
        this.bannerTimer = null;
        this.updatePanel();
      }, durationMs);
    }
  }

  private showRemainderHint(nodeId: string, durationMs: number = 1200): void {
    // Draw a transient ring where remainder stays after capture
    drawHighlightRing(this.overlayLayer, nodeId, "#ff9f40", 4);
    if (this.remainderTimer) window.clearTimeout(this.remainderTimer);
    this.remainderTimer = window.setTimeout(() => {
      this.remainderTimer = null;
      clearOverlays(this.overlayLayer);
      this.updatePanel();
    }, durationMs);
  }

  private async applyChosenMove(move: Move): Promise<void> {
    // Track node path for notation
    if (this.currentTurnNodes.length === 0) {
      this.currentTurnNodes.push(move.from);
    }
    this.currentTurnNodes.push(move.to);
    if (move.kind === "capture") {
      this.currentTurnHasCapture = true;
    }
    
    let next: GameState & { didPromote?: boolean };
    try {
      next = await this.driver.submitMove(move);
    } catch (err) {
      this.playSfx("error");
      // eslint-disable-next-line no-console
      console.error("[controller] driver submitMove failed", err);
      const msg = err instanceof Error ? err.message : "Move failed";

      // In online mode, a failed submit often means our local view is stale
      // (opponent moved, grace timeout fired, etc). Resync once so UI doesn't
      // stay in an inconsistent state (e.g. still showing Select while server is over).
      if (this.driver.mode === "online") {
        try {
          await (this.driver as OnlineGameDriver).fetchLatest();
          this.state = this.driver.getState();
          this.lockedCaptureFrom = null;
          this.lockedCaptureDir = null;
          this.jumpedSquares.clear();
          this.currentTurnNodes = [];
          this.currentTurnHasCapture = false;
          this.clearSelection();
          this.renderAuthoritative();

          const allLegal = generateLegalMoves(this.state);
          this.mandatoryCapture = allLegal.length > 0 && allLegal[0].kind === "capture";
          this.recomputeRepetitionCounts();

          // If the resynced state is actually over, lock the UI permanently.
          if (this.checkAndHandleCurrentPlayerLost()) return;
        } catch {
          // ignore resync errors
        }
      }

      // If the server says the game is over, keep the UI consistent.
      if (typeof msg === "string" && msg.toLowerCase().startsWith("game over")) {
        this.isGameOver = true;
        this.clearSelection();
        this.showBanner("Game Over", 0);
        this.showGameOverToast("Game Over");
        this.updatePanel();
        this.fireHistoryChange("gameOver");
        return;
      }

      this.showBanner(msg, 2500);
      return;
    }
    if (import.meta.env && import.meta.env.DEV) {
      // eslint-disable-next-line no-console
      console.log("[controller] apply", move);
    }

    this.playSfx(move.kind === "capture" ? "capture" : "move");
    if (next.didPromote) this.playSfx("promote");

    this.state = next;
    
    // Animate the move before rendering (both quiet moves and captures)
    if (this.animationsEnabled) {
      const movingGroup = this.piecesLayer.querySelector(`g.stack[data-node="${move.from}"]`) as SVGGElement | null;
      if (movingGroup) {
        const countsLayer = ensureStackCountsLayer(this.svg);
        const movingCount = countsLayer.querySelector(`g.stackCount[data-node="${move.from}"]`) as SVGGElement | null;
        await animateStack(this.svg, this.overlayLayer, move.from, move.to, movingGroup, 300, movingCount ? [movingCount] : []);
      }
    }
    
    // Now render the new state after animation
    this.renderAuthoritative();

    // Dead-play / server-enforced game over can happen mid-capture-chain.
    const forcedMsg = (this.state as any).forcedGameOver?.message as string | undefined;
    if (typeof forcedMsg === "string" && forcedMsg.length > 0) {
      this.isGameOver = true;
      this.lockedCaptureFrom = null;
      this.lockedCaptureDir = null;
      this.jumpedSquares.clear();
      this.clearSelection();

      // In local mode, capture chains normally push history at turn boundary.
      // If the game ends mid-turn, record the final authoritative state now.
      if (this.driver.mode !== "online") {
        const separator = this.currentTurnHasCapture ? " × " : " → ";
        const boardSize = this.state.meta?.boardSize ?? 7;
        const notation = this.currentTurnNodes.map((id) => nodeIdToA1(id, boardSize)).join(separator);
        this.driver.pushHistory(this.state, notation);
      }
      this.currentTurnNodes = [];
      this.currentTurnHasCapture = false;
      this.showBanner(forcedMsg, 0);
      this.showGameOverToast(forcedMsg);
      this.fireHistoryChange("gameOver");
      return;
    }
    
    // Clear overlays immediately after move is rendered
    // Also cancel any pending remainder hint timers
    if (this.remainderTimer) {
      window.clearTimeout(this.remainderTimer);
      this.remainderTimer = null;
    }
    clearOverlays(this.overlayLayer);
    
    if (move.kind === "capture") {
      // Track the jumped-over square to prevent re-jumping it
      this.jumpedSquares.add(move.over);

      const lastDir = this.captureDir(move.from, move.to);

      const rulesetId = this.state.meta?.rulesetId ?? "lasca";
      const isDama = rulesetId === "dama";
      const isDamasca = rulesetId === "damasca" || rulesetId === "damasca_classic";
      const isLasca = rulesetId === "lasca";
      const damaCaptureRemoval = isDama ? getDamaCaptureRemovalMode(this.state) : null;
      
      // Check if promotion happened
      const didPromote = next.didPromote || false;
      
      // Check if there are more captures available from the destination
      const allCaptures = generateLegalMoves(this.state, {
        forcedFrom: move.to,
        ...((isLasca || isDama || isDamasca)
          ? { excludedJumpSquares: this.jumpedSquares, ...(isDama || isDamasca ? { lastCaptureDir: lastDir } : {}) }
          : {}),
      }).filter((m) => m.kind === "capture");
      const moreCapturesFromDest = allCaptures;
      
      // If promoted and rule says stop on promotion, end the chain
      if (didPromote && RULES.stopCaptureOnPromotion) {
        if (isDama) {
          // Dama promotes only at the end of the sequence; if we ever get here,
          // still finalize the chain correctly.
          if (this.driver.mode === "online") {
            this.state = await (this.driver as OnlineGameDriver).finalizeCaptureChainRemote({
              rulesetId: "dama",
              state: this.state,
              landing: move.to,
              jumpedSquares: this.jumpedSquares,
            });
          } else {
            this.state = this.driver.finalizeCaptureChain({
              rulesetId: "dama",
              state: this.state,
              landing: move.to,
              jumpedSquares: this.jumpedSquares,
            });
          }
        } else if (isDamasca) {
          // Damasca should not promote mid-chain, but finalize defensively.
          const damascaRulesetId = (rulesetId === "damasca_classic" ? "damasca_classic" : "damasca") as
            | "damasca"
            | "damasca_classic";
          if (this.driver.mode === "online") {
            this.state = await (this.driver as OnlineGameDriver).finalizeCaptureChainRemote({
              rulesetId: damascaRulesetId,
              state: this.state,
              landing: move.to,
            });
          } else {
            this.state = this.driver.finalizeCaptureChain({
              rulesetId: damascaRulesetId,
              state: this.state,
              landing: move.to,
            });
          }
        }
        // Switch turn now
        if (this.driver.mode === "online") {
          const separator = this.currentTurnHasCapture ? " × " : " → ";
          const boardSize = this.state.meta?.boardSize ?? 7;
          const notation = this.currentTurnNodes.map((id) => nodeIdToA1(id, boardSize)).join(separator);
          try {
            this.state = await (this.driver as OnlineGameDriver).endTurnRemote(notation);
          } catch (err) {
            const msg = err instanceof Error ? err.message : "End turn failed";
            this.showBanner(msg, 2500);
            return;
          }
        } else {
          this.state = endTurn(this.state);
        }

        // In Dama, finalization may remove jumped pieces and/or promote.
        // We already rendered after applyMove, so re-render now to reflect finalization.
        if (
          (isDama && (damaCaptureRemoval === "end_of_sequence" || Boolean((this.state as any).didPromote))) ||
          (isDamasca && Boolean((this.state as any).didPromote))
        ) {
          this.renderAuthoritative();
        }

        this.lockedCaptureFrom = null;
        this.jumpedSquares.clear();
        this.clearSelection();
        
        // Record state in history at turn boundary
        if (this.driver.mode !== "online") {
          const separator = this.currentTurnHasCapture ? " × " : " → ";
          const boardSize = this.state.meta?.boardSize ?? 7;
          const notation = this.currentTurnNodes.map((id) => nodeIdToA1(id, boardSize)).join(separator);
          this.driver.pushHistory(this.state, notation);
        }
        this.currentTurnNodes = [];
        this.currentTurnHasCapture = false;
        this.fireHistoryChange("move");
        
        // Check for threefold repetition draw
        if (this.recordRepetitionForCurrentState()) {
          const rulesetId2 = this.state.meta?.rulesetId ?? "lasca";
          if (rulesetId2 === "damasca" || rulesetId2 === "damasca_classic") {
            this.state = adjudicateDamascaDeadPlay(this.state, "DAMASCA_THREEFOLD_REPETITION", "threefold repetition");

            // Update the last history entry so export/undo sees the adjudication.
            if (this.driver.mode !== "online") {
              const snap2 = this.driver.exportHistorySnapshots();
              if (snap2.states.length > 0 && snap2.currentIndex >= 0) {
                snap2.states[snap2.currentIndex] = this.state;
                this.driver.replaceHistory(snap2);
              }
            }

            this.isGameOver = true;
            this.clearSelection();
            {
              const msg = (this.state as any).forcedGameOver?.message ?? "Game Over";
              this.showBanner(msg, 0);
              this.showGameOverToast(msg);
            }
            this.fireHistoryChange("gameOver");
            return;
          }

          this.isGameOver = true;
          this.clearSelection();
          this.showBanner("Draw by threefold repetition", 0);
          this.showGameOverToast("Draw by threefold repetition");
          this.fireHistoryChange("gameOver");
          return;
        }
        
        // Update mandatory capture for new turn
        const allLegal = generateLegalMoves(this.state);
        this.mandatoryCapture = allLegal.length > 0 && allLegal[0].kind === "capture";
        
        // Check for game over - check if the player who now has the turn can play
        const gameResult = checkCurrentPlayerLost(this.state);
        if (gameResult.winner) {
          this.isGameOver = true;
          {
            const msg = gameResult.reason || "Game Over";
            this.showBanner(msg, 0);
            this.showGameOverToast(msg);
          }
          this.fireHistoryChange("gameOver");
          return;
        }

        this.maybeToastTurnChange();
        
        this.showBanner("Promoted — capture turn ends");
        // Don't show remainder hint - it will interfere with next turn's overlays
        return;
      }
      
      // If more captures available from destination, chain the capture
      if (moreCapturesFromDest.length > 0) {
        this.lockedCaptureFrom = move.to;
        this.lockedCaptureDir = lastDir;
        this.selected = move.to;
        this.showSelection(move.to);
        this.showBanner("Continue capture");
        // Don't show remainder hint during chain - it will be cleared when selection is shown
        return;
      }
      
      // No more captures, switch turn and end
      if (isDama) {
        if (this.driver.mode === "online") {
          this.state = await (this.driver as OnlineGameDriver).finalizeCaptureChainRemote({
            rulesetId: "dama",
            state: this.state,
            landing: move.to,
            jumpedSquares: this.jumpedSquares,
          });
        } else {
          this.state = this.driver.finalizeCaptureChain({
            rulesetId: "dama",
            state: this.state,
            landing: move.to,
            jumpedSquares: this.jumpedSquares,
          });
        }
      } else if (isDamasca) {
        const damascaRulesetId = (rulesetId === "damasca_classic" ? "damasca_classic" : "damasca") as
          | "damasca"
          | "damasca_classic";
        if (this.driver.mode === "online") {
          this.state = await (this.driver as OnlineGameDriver).finalizeCaptureChainRemote({
            rulesetId: damascaRulesetId,
            state: this.state,
            landing: move.to,
          });
        } else {
          this.state = this.driver.finalizeCaptureChain({
            rulesetId: damascaRulesetId,
            state: this.state,
            landing: move.to,
          });
        }
      }
      if (this.driver.mode === "online") {
        const separator = this.currentTurnHasCapture ? " × " : " → ";
        const boardSize = this.state.meta?.boardSize ?? 7;
        const notation = this.currentTurnNodes.map((id) => nodeIdToA1(id, boardSize)).join(separator);
        try {
          this.state = await (this.driver as OnlineGameDriver).endTurnRemote(notation);
        } catch (err) {
          const msg = err instanceof Error ? err.message : "End turn failed";
          this.showBanner(msg, 2500);
          return;
        }
      } else {
        this.state = endTurn(this.state);
      }

      // Dama may promote during finalization even in immediate-removal mode.
      // Re-render so the promotion is visible before the opponent starts their turn.
      if (
        (isDama && (damaCaptureRemoval === "end_of_sequence" || Boolean((this.state as any).didPromote))) ||
        (isDamasca && Boolean((this.state as any).didPromote))
      ) {
        this.renderAuthoritative();
      }

      this.lockedCaptureFrom = null;
      this.lockedCaptureDir = null;
      this.jumpedSquares.clear();
      this.clearSelection();
      
      // Record state in history at turn boundary
      if (this.driver.mode !== "online") {
        const separator = this.currentTurnHasCapture ? " × " : " → ";
        const boardSize = this.state.meta?.boardSize ?? 7;
        const notation = this.currentTurnNodes.map((id) => nodeIdToA1(id, boardSize)).join(separator);
        this.driver.pushHistory(this.state, notation);
      }
      this.currentTurnNodes = [];
      this.currentTurnHasCapture = false;
      this.fireHistoryChange("move");
      
      // Check for threefold repetition draw
      if (this.recordRepetitionForCurrentState()) {
        const rulesetId2 = this.state.meta?.rulesetId ?? "lasca";
        if (rulesetId2 === "damasca" || rulesetId2 === "damasca_classic") {
          this.state = adjudicateDamascaDeadPlay(this.state, "DAMASCA_THREEFOLD_REPETITION", "threefold repetition");

          if (this.driver.mode !== "online") {
            const snap2 = this.driver.exportHistorySnapshots();
            if (snap2.states.length > 0 && snap2.currentIndex >= 0) {
              snap2.states[snap2.currentIndex] = this.state;
              this.driver.replaceHistory(snap2);
            }
          }

          this.isGameOver = true;
          this.clearSelection();
          {
            const msg = (this.state as any).forcedGameOver?.message ?? "Game Over";
            this.showBanner(msg, 0);
            this.showGameOverToast(msg);
          }
          this.fireHistoryChange("gameOver");
          return;
        }

        this.isGameOver = true;
        this.clearSelection();
        this.showBanner("Draw by threefold repetition", 0);
        this.showGameOverToast("Draw by threefold repetition");
        this.fireHistoryChange("gameOver");
        return;
      }
      
      // Update mandatory capture for new turn
      const allLegal = generateLegalMoves(this.state);
      this.mandatoryCapture = allLegal.length > 0 && allLegal[0].kind === "capture";
      
      // Check for game over - check if the player who now has the turn can play
      const gameResult = checkCurrentPlayerLost(this.state);
      if (gameResult.winner) {
        this.isGameOver = true;
        {
          const msg = gameResult.reason || "Game Over";
          this.showBanner(msg, 0);
          this.showGameOverToast(msg);
        }
        this.fireHistoryChange("gameOver");
        return;
      }

      this.maybeToastTurnChange();
      
      this.showBanner("Turn changed");
      // Don't show remainder hint - it will interfere with next turn's overlays
    } else {
      // Quiet move - turn already switched in applyMove
      this.clearSelection();
      
      // Record state in history at turn boundary
      const separator = this.currentTurnHasCapture ? " × " : " → ";
      const boardSize = this.state.meta?.boardSize ?? 7;
      const notation = this.currentTurnNodes.map((id) => nodeIdToA1(id, boardSize)).join(separator);
      if (this.driver.mode !== "online") {
        this.driver.pushHistory(this.state, notation);
      }
      this.currentTurnNodes = [];
      this.currentTurnHasCapture = false;
      this.fireHistoryChange("move");
      
      // Check for threefold repetition draw
      if (this.recordRepetitionForCurrentState()) {
        this.isGameOver = true;
        this.clearSelection();
        this.showBanner("Draw by threefold repetition", 0);
        this.showGameOverToast("Draw by threefold repetition");
        this.fireHistoryChange("gameOver");
        return;
      }
      
      // Update mandatory capture for new turn
      const allLegal = generateLegalMoves(this.state);
      this.mandatoryCapture = allLegal.length > 0 && allLegal[0].kind === "capture";
      
      // Check for game over after quiet move - check if current player can play
      const gameResult = checkCurrentPlayerLost(this.state);
      if (gameResult.winner) {
        this.isGameOver = true;
        {
          const msg = gameResult.reason || "Game Over";
          this.showBanner(msg, 0);
          this.showGameOverToast(msg);
        }
        this.fireHistoryChange("gameOver");
        return;
      }
      
      // Update panel to show capture message if needed
      this.updatePanel();

      this.maybeToastTurnChange();
    }
  }

  private async onClick(ev: MouseEvent): Promise<void> {
    // Ignore clicks if game is over
    if (this.isGameOver) {
      return;
    }

    // Ignore human input when AI has locked input
    if (!this.inputEnabled) {
      return;
    }

    // Online UX: freeze play while opponent is disconnected (until reconnect or disconnect-forfeit).
    if (this.driver.mode === "online") {
      try {
        const remote = this.driver as OnlineGameDriver;
        const selfId = remote.getPlayerId();
        const presence = remote.getPresence();
        if (presence && selfId && selfId !== "spectator") {
          const opponentId = Object.keys(presence).find((pid) => pid !== selfId) ?? null;
          const opp = opponentId ? (presence as any)[opponentId] : null;
          if (opp && opp.connected === false) {
            this.clearSelection();

            const now = Date.now();
            if (now - this.lastOpponentDisconnectedBlockToastAt > 1500) {
              this.lastOpponentDisconnectedBlockToastAt = now;
              this.showToast("Opponent disconnected — waiting for reconnect (click the opponent status icon for details)", 2200);
            }
            return;
          }
        }
      } catch {
        // If presence isn't available, don't block input.
      }
    }

    // In online mode, ignore input when it's not your turn.
    if (!this.isLocalPlayersTurn()) {
      this.clearSelection();
      return;
    }

    let nodeId = this.resolveClickedNode(ev.target);
    if (import.meta.env && import.meta.env.DEV) {
      // eslint-disable-next-line no-console
      console.log("[controller] click", { target: ev.target, resolved: nodeId, selected: this.selected, targets: this.currentTargets });
    }
    if (!nodeId) {
      // Try geometric hit-test against current target circles
      nodeId = this.hitTestTargets(ev);
    }
    if (!nodeId) {
      this.clearSelection();
      return;
    }

    if (this.selected && this.currentTargets.includes(nodeId)) {
      const move = this.currentMoves.find(m => m.to === nodeId && m.from === this.selected);
      if (!move) {
        this.clearSelection();
        return;
      }
      
      
      await this.applyChosenMove(move);
      return;
    }

    // If we're in a capture chain, only allow clicking the locked piece or its targets
    if (this.lockedCaptureFrom) {
      if (nodeId === this.lockedCaptureFrom) {
        // Clicked the piece that must continue capturing - reselect it
        this.selected = nodeId;
        this.showSelection(nodeId);
        return;
      }
      // Otherwise, clicking anything else during a locked chain does nothing
      return;
    }

    // Select only your own stack; clicking empty node clears selection
    if (this.isOwnStack(nodeId)) {
      this.selected = nodeId;
      this.playSfx("select");
      this.showSelection(nodeId);
    } else {
      this.clearSelection();
    }
  }
}
